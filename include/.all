CONCAT_ID=##concat##
##concat##CQAlignEdit.h
#ifndef CQAlignEdit_H
#define CQAlignEdit_H

#include <QFrame>

class QStyleOptionComboBox;

class CQAlignEdit : public QFrame {
  Q_OBJECT

 public:
  CQAlignEdit(QWidget *parent=nullptr);
 ~CQAlignEdit();

  const Qt::Alignment &align() const { return align_; }
  void setAlign(const Qt::Alignment &v);

  QString toString() const;

  QSize sizeHint() const override;

  static QString toString(Qt::Alignment align);
  static Qt::Alignment fromString(const QString &str);

 signals:
  void valueChanged(Qt::Alignment);

 private:
  void paintEvent(QPaintEvent *) override;

  void mousePressEvent(QMouseEvent *) override;

  void initStyleOption(QStyleOptionComboBox &opt) const;

 private:
  Qt::Alignment align_ { Qt::AlignCenter };
};

//------

class CQAlignEditMenuWidget : public QFrame {
  Q_OBJECT

 public:
  CQAlignEditMenuWidget(CQAlignEdit *edit);

  QSize sizeHint() const override;

 private:
  void resizeEvent(QResizeEvent *) override;

  void paintEvent(QPaintEvent *) override;

  void mouseMoveEvent(QMouseEvent *) override;

  void mousePressEvent(QMouseEvent *) override;

  void drawAlignRect(QPainter *p, Qt::Alignment rectAlign, bool on);

 private:
  struct Rect {
    QRect r;
    bool  inside { false };

    Rect(const QRect &r=QRect()) :
     r(r) {
    }
  };

  typedef std::map<Qt::Alignment, Rect> AlignRect;

  CQAlignEdit *edit_ { nullptr };
  AlignRect    alignRect_;
};

#endif
##concat##CQAlphaButton.h
#ifndef CQAlphaButton_H
#define CQAlphaButton_H

#include <QWidget>

class CQAlphaButton : public QWidget {
  Q_OBJECT

 public:
  CQAlphaButton(QWidget *parent=nullptr);

  double getAlpha() const;

  void setAlpha(double alpha);

  void setColor(QColor color);

 private:
  void paintEvent(QPaintEvent *) override;

  void mousePressEvent  (QMouseEvent *e) override;
  void mouseMoveEvent   (QMouseEvent *e) override;
  void mouseReleaseEvent(QMouseEvent *e) override;

  void posToAlpha(int pos);
  int alphaToPos();

 signals:
  void valueChanged();

 private:
  double alpha_ { 1.0 };
  QColor fg_, bg_;
};

#endif
##concat##CQAngleSpinBox.h
#ifndef CQANGLE_SPINBOX_H
#define CQANGLE_SPINBOX_H

#include <CAngle.h>
#include <QDoubleSpinBox>

class CQAngleSpinBox : public QDoubleSpinBox {
  Q_OBJECT

 public:
  CQAngleSpinBox(QWidget *parent, const CAngle &angle=CAngle());
  CQAngleSpinBox(const CAngle &angle=CAngle());

  virtual ~CQAngleSpinBox() { }

  const CAngle &getAngle() const { return angle_; }
  void setAngle(const CAngle &angle);

 private:
  void init();

 signals:
  void angleChanged(const CAngle &);

 private slots:
  void valueChangedSlot(double a);

 private:
  CAngle angle_;
};

#endif
##concat##CQApp.h
#ifndef CQApp_H
#define CQApp_H

//#define USE_OBJEDIT 1

#include <QApplication>

class CQStyle;
class CConfig;
class CQAppObjEditFilter;

#define CQAppInst CQApp::getApp()

class CQApp : public QApplication {
  Q_OBJECT

  Q_PROPERTY(bool darkTheme READ isDarkTheme WRITE setDarkTheme)

 public:
  static CQApp *getApp() { return app_; }

  CQApp(int &argc, char **argv);
 ~CQApp();

  CQStyle *style() const { return style_; }

  bool isDarkTheme() const;
  void setDarkTheme(bool b);

#ifdef USE_OBJEDIT
  void addObjEditFilter(QObject *o);
#endif

  static void showMetaEdit(QObject *obj=nullptr);
  static void showPerfDialog();

 private:
  static CQApp *app_;

  CQStyle*            style_         { nullptr };
  CConfig*            config_        { nullptr };
  CQAppObjEditFilter* objEditFilter_ { nullptr };
};

//---

#ifdef USE_OBJEDIT
class CQAppObjEditFilter : public QObject {
  Q_OBJECT

 protected:
  bool eventFilter(QObject *obj, QEvent *event) override;
};
#endif

#endif
##concat##CQAppOptions.h
#ifndef CQAppOptions_H
#define CQAppOptions_H

#include <CQDialog.h>

class CQAppOptions : public CQDialog {
  Q_OBJECT

 public:
  static void show();

 private:
  CQAppOptions(QWidget *parent=nullptr);

 private slots:
  void darkSlot(bool);

  void vfontSlot(const QFont &);
  void ffontSlot(const QFont &);

  void iconSizeChanged(int i);
  void largeIconSizeChanged(int i);
  void smallIconSizeChanged(int i);
};

#endif
##concat##CQArrow.h
#ifndef CQArrow_H
#define CQArrow_H

#include <QObject>
#include <QPointF>
#include <QPolygonF>
#include <QColor>

class QPainter;

#define ACCESSOR(T,V,G,S) \
const T &G() const { return V; } \
void S(const T &t) { V = t; }

#define ACCESSOR_IMPL_GET_DCL_SET(T,V,G,S) \
const T &G() const { return V; } \
void S(const T &t);

class CQArrowDevice;

class CQArrow : public QObject {
 public:
  Q_OBJECT

  Q_PROPERTY(double lineWidth READ lineWidth WRITE setLineWidth)

  Q_PROPERTY(bool     frontVisible   READ isFHead         WRITE setFHead)
  Q_PROPERTY(HeadType frontType      READ frontType       WRITE setFrontType)
  Q_PROPERTY(double   frontAngle     READ frontAngle      WRITE setFrontAngle)
  Q_PROPERTY(double   frontBackAngle READ frontBackAngle  WRITE setFrontBackAngle)
  Q_PROPERTY(double   frontLength    READ frontLength     WRITE setFrontLength)
  Q_PROPERTY(bool     frontLineEnds  READ isFrontLineEnds WRITE setFrontLineEnds)

  Q_PROPERTY(bool     tailVisible    READ isTHead        WRITE setTHead)
  Q_PROPERTY(HeadType tailType       READ tailType       WRITE setTailType)
  Q_PROPERTY(double   tailAngle      READ tailAngle      WRITE setTailAngle)
  Q_PROPERTY(double   tailBackAngle  READ tailBackAngle  WRITE setTailBackAngle)
  Q_PROPERTY(double   tailLength     READ tailLength     WRITE setTailLength)
  Q_PROPERTY(bool     tailLineEnds   READ isTailLineEnds WRITE setTailLineEnds)

  Q_PROPERTY(bool   filled      READ isFilled    WRITE setFilled)
  Q_PROPERTY(bool   stroked     READ isStroked   WRITE setStroked)
  Q_PROPERTY(double strokeWidth READ strokeWidth WRITE setStrokeWidth)

  Q_PROPERTY(bool debugPoints READ isDebugPoints WRITE setDebugPoints)
  Q_PROPERTY(bool debugText   READ isDebugText   WRITE setDebugText  )

  Q_ENUMS(HeadType)

 public:
  enum class HeadType {
    NONE,
    TRIANGLE,
    STEALTH,
    DIAMOND,
    LINE,
  };

 public:
  CQArrow(const QPointF &from=QPointF(0, 0), const QPointF &to=QPointF(1, 1));

  ACCESSOR(QPointF, from_     , from      , setFrom);
  ACCESSOR(QPointF, to_       , to        , setTo);
  ACCESSOR(bool   , relative_ , isRelative, setRelative);
  ACCESSOR(double , lineWidth_, lineWidth , setLineWidth);

  ACCESSOR_IMPL_GET_DCL_SET(HeadType, frontData_.type, frontType, setFrontType);

  ACCESSOR(bool    , frontData_.visible  , isFHead        , setFHead);
  ACCESSOR(double  , frontData_.angle    , frontAngle     , setFrontAngle);
  ACCESSOR(double  , frontData_.backAngle, frontBackAngle , setFrontBackAngle);
  ACCESSOR(double  , frontData_.length   , frontLength    , setFrontLength);
  ACCESSOR(bool    , frontData_.lineEnds , isFrontLineEnds, setFrontLineEnds);

  ACCESSOR_IMPL_GET_DCL_SET(HeadType, tailData_.type, tailType, setTailType);

  ACCESSOR(bool    , tailData_.visible  , isTHead       , setTHead);
  ACCESSOR(double  , tailData_.angle    , tailAngle     , setTailAngle);
  ACCESSOR(double  , tailData_.backAngle, tailBackAngle , setTailBackAngle);
  ACCESSOR(double  , tailData_.length   , tailLength    , setTailLength);
  ACCESSOR(bool    , tailData_.lineEnds , isTailLineEnds, setTailLineEnds);

  ACCESSOR(bool   , filled_     , isFilled     , setFilled);
  ACCESSOR(bool   , stroked_    , isStroked    , setStroked);
  ACCESSOR(double , strokeWidth_, strokeWidth  , setStrokeWidth);
  ACCESSOR(bool   , debugPoints_, isDebugPoints, setDebugPoints);
  ACCESSOR(bool   , debugText_  , isDebugText  , setDebugText);

  ACCESSOR(bool, inside_, isInside, setInside);

  bool isDebugLabels() const { return isDebugPoints() || isDebugText(); }

  void draw(QPainter *painter, CQArrowDevice *device=nullptr);

  bool contains(const QPointF &p) const;

 private:
  using Points = QVector<QPointF>;

 private:
  void drawPolygon(const Points &points, double w=1.0, bool filled=false, bool stroked=false);

  void drawLine(const QPointF &point1, const QPointF &point2, double width=1.0);

  struct PointLabel {
    PointLabel(const QPointF &point, const QString &text, bool above) :
     point(point), text(text), above(above) {
    }

    QPointF point;
    QString text;
    bool    above { true };
  };

  using PointLabels = std::vector<PointLabel>;

  void drawPointSymbolLabel(const QPointF &point, const QString &text, bool above=true);

  void drawPointSymbol(const QPointF &point);
  void drawPointLabel (const QPointF &point, const QString &text, bool above=true);

#if 0
  double pixelWidthToWindowWidth  (double p);
  double pixelHeightToWindowHeight(double p);
#endif

  double windowWidthToPixelWidth  (double w);
  double windowHeightToPixelHeight(double w);

  QPointF windowToPixel(const QPointF &w);
//QPointF pixelToWindow(const QPointF &w);

  static double pointLineDistance(const QPointF &p, const QPointF &p1, const QPointF &p2);

 private:
  struct HeadData {
    bool     visible   { false };
    HeadType type      { HeadType::NONE };
    double   angle     { -1 };
    double   backAngle { -1 };
    double   length    { -1 };
    bool     lineEnds  { false };
  };

  struct Line {
    QPointF p1;
    QPointF p2;
    bool    valid { false };

    Line() { }

    Line(const QPointF &p1, const QPointF &p2) :
     p1(p1), p2(p2), valid(true) {
    }

    void reset() { valid = false; }

    double distance(const QPointF &p) const {
      return CQArrow::pointLineDistance(p, p1, p2);
    }
  };

  struct Polygon {
    QPolygonF points;
    bool      valid { false };

    Polygon() { }

    Polygon(const Points &points) :
     points(points), valid(true) {
    }

    void reset() { valid = false; }
  };

  //---

  int            ind_         { -1 };
  QPointF        from_        { 0, 0 };
  QPointF        to_          { 1, 1 };
  bool           relative_    { false };
  double         lineWidth_   { -1 };
  HeadData       frontData_;
  HeadData       tailData_;
  bool           filled_      { true };
  bool           stroked_     { false };
  double         strokeWidth_ { -1 };
  bool           debugPoints_ { false };
  bool           debugText_   { false };
  QPainter*      painter_     { nullptr };
  CQArrowDevice* device_      { nullptr };
  QColor         fillColor_   { 100, 100, 200 };
  QColor         strokeColor_ { 100, 200, 100 };
  QColor         textColor_   { 255, 0, 0 };
  bool           inside_      { false };

  mutable Line    frontLine1_;
  mutable Line    frontLine2_;
  mutable Line    endLine1_;
  mutable Line    endLine2_;
  mutable Line    midLine_;
  mutable Polygon frontPoly_;
  mutable Polygon tailPoly_;
  mutable Polygon arrowPoly_;
};

class CQArrowDevice {
 public:
  CQArrowDevice() { }

  virtual ~CQArrowDevice() { }

  virtual QPointF windowToPixel(const QPointF &w) = 0;
  virtual QPointF pixelToWindow(const QPointF &p) = 0;
};

#endif
##concat##CQAutoHide.h
#ifndef CQAutoHide_H
#define CQAutoHide_H

#include <QWidget>
#include <QPointer>
#include <QSet>

class CQAutoHide : public QObject {
  Q_OBJECT

 public:
  CQAutoHide(QWidget *w=nullptr);

  void setWidget(QWidget *w);

  bool active() const { return active_; }

  void setActive(bool active);

  void addWidget(QWidget *w);

  void addRect(const QRect &r);

  void clear();

 signals:
  void autoHide();

 private:
  bool eventFilter(QObject *obj, QEvent *event) override;

  bool processEvent(QObject *obj, QEvent *event);

  bool isPreviewValid() const;

  bool isPreviewValid(QWidget *w, const QPoint &gp) const;

  bool checkPreviewRects(const QPoint &gp, int tol=0) const;

  bool isPreviewWidget(QWidget *w) const;

  bool isModalDialogWidget(QWidget *w) const;

 private:
  using WidgetP = QPointer<QWidget>;
  using Widgets = QSet<QWidget*>;
  using Rects   = QList<QRect>;

  WidgetP  w_;
  bool     active_        { false };
  bool     hideOnRelease_ { false };
  bool     menuActive_    { false };
  QWidget* pressWidget_   { nullptr };
  Widgets  widgets_;
  Rects    rects_;
};

#endif
##concat##CQBBox2DEdit.h
#ifndef CQBBox2DEdit_H
#define CQBBox2DEdit_H

#include <QLineEdit>
#include <QDoubleSpinBox>
#include <QHBoxLayout>
#include <CBBox2D.h>

class CQBBox2DEdit : public QFrame {
  Q_OBJECT

 public:
  CQBBox2DEdit(QWidget *parent, const CBBox2D &value=CBBox2D(0, 0, 1, 1));
  CQBBox2DEdit(const CBBox2D &value=CBBox2D(0, 0, 1, 1));

  CQBBox2DEdit(QWidget *parent, const QRectF &value);
  CQBBox2DEdit(const QRectF &value);

  virtual ~CQBBox2DEdit() { }

  void setValue(const CBBox2D &rect);
  void setValue(const QRectF &rect);

  const CBBox2D &getValue() const;
  QRectF getQValue() const;

 private:
  void init(const CBBox2D &value);

 private slots:
  void editingFinishedI();

 signals:
  void valueChanged();

 private:
  void updateRange();

  void rectToWidget();
  bool widgetToPoint();

 private:
  CBBox2D      rect_           { 0, 0, 1, 1 };
  QLineEdit*   edit_           { nullptr };
  QHBoxLayout* layout_         { nullptr };
  mutable bool disableSignals_ { false };
};

#endif
##concat##CQBrushUtil.h
#ifndef CQBrushUtil_H
#define CQBrushUtil_H

#ifdef CQUTIL_BRUSH
#include <CBrush.h>
#endif

#include <QBrush>

namespace CQBrushUtil {

#ifdef CQUTIL_BRUSH
QBrush toQBrush(const CBrush &brush);
#endif

}

#endif
##concat##CQCheckBox.h
#ifndef CQCheckBox_H
#define CQCheckBox_H

#include <QCheckBox>

class CQCheckBox : public QCheckBox {
  Q_OBJECT

 public:
  CQCheckBox(QWidget *parent=nullptr);
  CQCheckBox(const QString &text, QWidget *parent=nullptr);

 private slots:
  void stateSlot(int b);
};

#endif
##concat##CQColorChooser.h
#ifndef CQColorChooser_H
#define CQColorChooser_H

#include <QWidget>

class CQIconButton;
class CQAlphaButton;

class QLineEdit;
class QPushButton;
class QToolButton;
class QLabel;

class CQColorChooser : public QWidget {
  Q_OBJECT

  Q_PROPERTY(bool    editable  READ getEditable WRITE setEditable )
  Q_PROPERTY(uint    style     READ getStyles   WRITE setStyles   )
  Q_PROPERTY(QColor  color     READ color       WRITE setColor    )
  Q_PROPERTY(QString colorName READ colorName   WRITE setColorName)

  Q_ENUMS(Style)

 public:
  enum Style {
    Text        = (1<<0),
    ColorButton = (1<<1),
    ColorLabel  = (1<<2),
    ImageButton = (1<<3),
    AlphaButton = (1<<4)
  };

 public:
  CQColorChooser(QWidget *parent=0);

  CQColorChooser(uint styles, QWidget *parent=0);

  bool getEditable() const { return editable_; }
  void setEditable(bool editable=true);

  uint getStyles() const { return styles_; }
  void setStyles(uint styles);

  //---

  void setTextStyle(bool b) {
    uint styles = getStyles();

    if (b) styles |=  uint(Text);
    else   styles &= ~uint(Text);

    setStyles(styles);
  }

  bool hasTextStyle() const { return styles_ & Text; }

  //---

  void setColorButtonStyle(bool b) {
    uint styles = getStyles();

    if (b) styles |=  uint(ColorButton);
    else   styles &= ~uint(ColorButton);

    setStyles(styles);
  }

  bool hasColorButtonStyle() const { return styles_ & ColorButton; }

  //---

  void setColorLabelStyle(bool b) {
    uint styles = getStyles();

    if (b) styles |=  uint(ColorLabel);
    else   styles &= ~uint(ColorLabel);

    setStyles(styles);
  }

  bool hasColorLabelStyle() const { return styles_ & ColorLabel; }

  //---

  void setImageButtonStyle(bool b) {
    uint styles = getStyles();

    if (b) styles |=  uint(ImageButton);
    else   styles &= ~uint(ImageButton);

    setStyles(styles);
  }

  bool hasImageButtonStyle() const { return styles_ & ImageButton; }

  //---

  void setAlphaButtonStyle(bool b) {
    uint styles = getStyles();

    if (b) styles |=  uint(AlphaButton);
    else   styles &= ~uint(AlphaButton);

    setStyles(styles);
  }

  bool hasAlphaButtonStyle() const { return styles_ & AlphaButton; }

  //---

  const QColor &color() const;
  void setColor(const QColor &color, double alpha=1.0);

  QString colorName() const;
  void setColorName(const QString &colorName, double alpha=1.0);

  double getAlpha() const;
  void setAlpha(double alpha);

  QLineEdit *getTextWidget() const { return cedit_; }

 private:
  void init();
  void update();
  void changeColor();
  void applyColor();

  void setWidgetBackground(QWidget *widget, const QColor &color);

 private slots:
  void textColorChanged();
  void imageButtonClicked();
  void colorButtonClicked();
  void alphaButtonChanged();

 signals:
  void colorChanged(const QColor &color);
  void colorChanged(const QString &colorName);

  void colorApplied(const QColor &color);
  void colorApplied(const QString &colorName);

 private:
  uint           styles_    { 0 };
  bool           editable_  { true };
  bool           has_alpha_ { false };
  QColor         color_;
  QString        colorName_;
  double         alpha_     { 1.0 };
  QLineEdit     *cedit_     { nullptr }; // text color name
  QToolButton   *cbutton_   { nullptr }; // click color button
  QLabel        *clabel_    { nullptr }; // static color button
  CQAlphaButton *alphab_    { nullptr }; // alpha slider
  CQIconButton  *button_    { nullptr }; // image click button
};

#endif
##concat##CQColorEdit.h
#ifndef CQColorEdit_H
#define CQColorEdit_H

#include <QFrame>

class CQWidgetMenu;
class QHBoxLayout;
class QLineEdit;
class QPushButton;
class QStyleOptionComboBox;
class QColorDialog;

class CQColorEdit : public QFrame {
  Q_OBJECT

  Q_PROPERTY(QColor  color     READ color      WRITE setColor    )
  Q_PROPERTY(QString colorName READ colorName  WRITE setColorName)
  Q_PROPERTY(bool    editable  READ isEditable WRITE setEditable )

 public:
  CQColorEdit(QWidget *parent=nullptr);

  //---

  const QColor &color() const { return color_; }
  void setColor(const QColor &color);

  QString colorName() const { return colorName_; }
  void setColorName(const QString &colorName);

  bool isEditable() const { return editable_; }
  void setEditable(bool editable=true);

  void setNoFocus();

  //---

  QLineEdit *lineEdit() const { return edit_; }

  void paintEvent(QPaintEvent *) override;

  void resizeEvent(QResizeEvent *) override;

 private:
  friend class CQColorEditMenuButton;

  void updateEdit();

  void setNoFocusHier(QWidget *w);

  void emitColorChanged();

  void initStyle(QStyleOptionComboBox &opt);

 private slots:
  void textChangedSlot();

  void buttonSlot();

  void showMenuSlot();
  void hideMenuSlot();

  void colorSlot(const QColor &color);

  void closeMenuSlot();

 signals:
  void colorChanged(const QColor &color);
  void colorChanged(const QString &colorName);

  void menuHidden();

 private:
  bool          editable_   { true };
  QColor        color_;
  QString       colorName_;
  QLineEdit*    edit_       { nullptr }; // text edit
  QPushButton*  button_     { nullptr }; // menu button
  CQWidgetMenu* menu_       { nullptr };
  QColorDialog* colorDlg_   { nullptr };
};

//---

#include <QLineEdit>

class CQColorEditEdit : public QLineEdit {
  Q_OBJECT

 public:
  CQColorEditEdit(CQColorEdit *edit);

  void paintEvent(QPaintEvent *) override;

 private:
  CQColorEdit *edit_ { nullptr };
};

//---

#include <QPushButton>

class CQColorEditMenuButton : public QPushButton {
  Q_OBJECT

 public:
  CQColorEditMenuButton(CQColorEdit *edit);

  void paintEvent(QPaintEvent *) override;

 private:
  CQColorEdit *edit_ { nullptr };
};

#endif
##concat##CQComboSlider.h
#ifndef CQComboSlider_H
#define CQComboSlider_H

#include <QWidget>

class CQRealSpin;
class CQIntegerSpin;

class QSlider;
class QSpinBox;

// combined double slider+spinner
class CQComboSlider : public QWidget {
  Q_OBJECT

  Q_PROPERTY(double value READ value WRITE setValue)

 public:
  CQComboSlider(QWidget *parent=nullptr);
  CQComboSlider(QWidget *parent, double defValue, double minimum, double maximum);

  void setRange(double minValue, double maxValue);

  double value() const { return value_; }
  void setValue(double d);

  double getSpan() const { return maxValue_ - minValue_; }

 private:
  void init();

  void updateWidgets();
  void updateSlider ();
  void updateSpinner();

  void setSliderValue (double d);
  void setSpinnerValue(double d);

 signals:
  void valueChanged(double);

 protected slots:
  void spinnerChanged(double);

  void sliderChanged(int);

 private:
  double      defValue_ { 0.0 };
  double      minValue_ { 0.0 };
  double      maxValue_ { 1.0 };
  double      value_    { 0.0 };
  QSlider*    slider_   { nullptr };
  CQRealSpin* spinner_  { nullptr };
};

//------

// combined int slider+spinner
class CQIntComboSlider : public QWidget {
  Q_OBJECT

  Q_PROPERTY(int value READ value WRITE setValue)

 public:
  CQIntComboSlider(QWidget* parent=nullptr);
  CQIntComboSlider(QWidget* parent, int defValue, int minimum, int maximum);

  void setRange(int minValue, int maxValue);

  int value() const { return value_; }
  void setValue(int i);

 private:
  void init();

  void updateWidgets();
  void updateSlider ();
  void updateSpinner();

  void setSliderValue (int i);
  void setSpinnerValue(int i);

 signals:
  void valueChanged(int);

 protected slots:
  void spinnerChanged(int);

  void sliderChanged(int);

 private:
  int            defValue_ { 0 };
  int            minValue_ { 0 };
  int            maxValue_ { 100 };
  int            value_    { 0 };
  QSlider*       slider_   { nullptr };
  CQIntegerSpin* spinner_  { nullptr };
};

#endif
##concat##CQDialog.h
#ifndef CQDIALOG_H
#define CQDIALOG_H

#include <QDialog>

class QGridLayout;
class QCheckBox;
class QGroupBox;
class QHBoxLayout;

class CQDialogForm : public QWidget {
  Q_OBJECT

 public:
  CQDialogForm(QWidget *parent=nullptr);

  QCheckBox *addCheckBox(const QString &name, const QObject *receiver=nullptr,
                         const char *member=nullptr);

  QGroupBox *addRadioButtons(const QString &name, const std::vector<QString> &names,
                             const QObject *receiver=nullptr, const char *member=nullptr);

  QWidget *addField(const QString &name, QWidget *w, bool stretch=false);

  void addStretch();

 private:
  QGridLayout *grid_ { nullptr };
  mutable int  row_  { 0 };
};

//---

class CQDialog : public QDialog {
  Q_OBJECT

 public:
  enum ButtonType {
    BUTTON_NONE   = 0,
    BUTTON_OK     = (1<<0),
    BUTTON_APPLY  = (1<<1),
    BUTTON_CANCEL = (1<<2),
    BUTTON_ALL    = (BUTTON_OK | BUTTON_APPLY | BUTTON_CANCEL)
  };

 public:
  CQDialog(QWidget *parent=nullptr, uint buttons=BUTTON_ALL);

  virtual ~CQDialog() { }

  void init();

  int exec();

  QCheckBox *addCheckBox(const QString &name, const QObject *receiver=nullptr,
                         const char *member=nullptr);

  QGroupBox *addRadioButtons(const QString &name, const std::vector<QString> &names,
                             const QObject *receiver=nullptr, const char *member=nullptr);

  QWidget *addField(const QString &name, QWidget *w, bool stretch=false);

  template<typename WIDGET>
  WIDGET *addFieldT(const QString &name, WIDGET *w, bool stretch=false) {
    return dynamic_cast<WIDGET *>(addField(name, w, stretch));
  }

  QPushButton *addButton(const QString &name);

  bool isAccepted() const { return accepted_; }

  void addStretch();

 signals:
  void accepted();

 protected:
  virtual void createWidgets(QWidget *) { }

  virtual void accept() { }
  virtual void reject() { }

 protected slots:
  void acceptSlot();
  void applySlot ();
  void rejectSlot();

 private:
  CQDialogForm *frame_             { nullptr };
  bool          initialized_       { false };
  bool          accepted_          { false };
  QHBoxLayout  *buttonFrameLayout_ { nullptr };
};

#endif
##concat##CQDragLabel.h
#ifndef CQDragLabel_H
#define CQDragLabel_H

#include <QLabel>

class CQDragLabel : public QLabel {
  Q_OBJECT

  Q_PROPERTY(bool   dragable READ isDragable WRITE setDragable)
  Q_PROPERTY(int    dragSize READ dragSize   WRITE setDragSize)
  Q_PROPERTY(double dragMin  READ dragMin    WRITE setDragMin )
  Q_PROPERTY(double dragMax  READ dragMax    WRITE setDragMax )

 public:
  CQDragLabel(QWidget *parent=nullptr);
  CQDragLabel(const QString &label, QWidget *parent=nullptr);

  bool isDragable() const { return dragable_; }
  void setDragable(bool b) { dragable_ = b; }

  int dragSize() const { return dragSize_; }
  void setDragSize(int i) { dragSize_ = i; }

  double dragMin() const { return dragMin_; }
  void setDragMin(double r) { dragMin_ = r; }

  double dragMax() const { return dragMax_; }
  void setDragMax(double r) { dragMax_ = r; }

  void mousePressEvent  (QMouseEvent *e) override;
  void mouseMoveEvent   (QMouseEvent *e) override;
  void mouseReleaseEvent(QMouseEvent *e) override;

 private:
  void init();

 signals:
  void dragValueChanged(double v);

 private:
  bool   pressed_  { false };
  QPoint pos_;
  bool   dragable_ { true };
  int    dragSize_ { 256 };
  double dragMin_  { -1.0 };
  double dragMax_  { 1.0 };
  int    lastDx_   { 0 };
};

#endif
##concat##CQDrawUtil.h
/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the QtGui module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Digia.  For licensing terms and
** conditions see http://qt.digia.com/licensing.  For further information
** use the contact form at http://qt.digia.com/contact-us.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Digia gives you certain additional
** rights.  These rights are described in the Digia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3.0 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU General Public License version 3.0 requirements will be
** met: http://www.gnu.org/copyleft/gpl.html.
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

#ifndef QDRAWUTIL_H
#define QDRAWUTIL_H

#include <QtCore/qnamespace.h>
#include <QtCore/qstring.h> // char*->QString conversion
#include <QtCore/qmargins.h>
#include <QtGui/qpixmap.h>
QT_BEGIN_HEADER

QT_BEGIN_NAMESPACE

QT_MODULE(Gui)

class QPainter;
#ifndef QT3_SUPPORT
class QColorGroup;
#endif
class QPalette;
class QPoint;
class QColor;
class QBrush;
class QRect;

//
// Standard shade drawing
//

Q_GUI_EXPORT void qDrawShadeLine(QPainter *p, int x1, int y1, int x2, int y2,
                                 const QPalette &pal, bool sunken = true,
                                 int lineWidth = 1, int midLineWidth = 0);

Q_GUI_EXPORT void qDrawShadeLine(QPainter *p, const QPoint &p1, const QPoint &p2,
                                 const QPalette &pal, bool sunken = true,
                                 int lineWidth = 1, int midLineWidth = 0);

Q_GUI_EXPORT void qDrawShadeRect(QPainter *p, int x, int y, int w, int h,
                                 const QPalette &pal, bool sunken = false,
                                 int lineWidth = 1, int midLineWidth = 0,
                                 const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawShadeRect(QPainter *p, const QRect &r,
                                 const QPalette &pal, bool sunken = false,
                                 int lineWidth = 1, int midLineWidth = 0,
                                 const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawShadePanel(QPainter *p, int x, int y, int w, int h,
                                  const QPalette &pal, bool sunken = false,
                                  int lineWidth = 1, const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawShadePanel(QPainter *p, const QRect &r,
                                  const QPalette &pal, bool sunken = false,
                                  int lineWidth = 1, const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawWinButton(QPainter *p, int x, int y, int w, int h,
                                 const QPalette &pal, bool sunken = false,
                                 const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawWinButton(QPainter *p, const QRect &r,
                                 const QPalette &pal, bool sunken = false,
                                 const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawWinPanel(QPainter *p, int x, int y, int w, int h,
                                const QPalette &pal, bool sunken = false,
                                const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawWinPanel(QPainter *p, const QRect &r,
                                const QPalette &pal, bool sunken = false,
                                const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawPlainRect(QPainter *p, int x, int y, int w, int h, const QColor &,
                                 int lineWidth = 1, const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawPlainRect(QPainter *p, const QRect &r, const QColor &,
                                 int lineWidth = 1, const QBrush *fill = 0);

#ifdef QT3_SUPPORT
//
// Use QStyle::itemRect(), QStyle::drawItem() and QStyle::drawArrow() instead.
//
Q_GUI_EXPORT QT3_SUPPORT QRect qItemRect(QPainter *p, Qt::GUIStyle gs, int x, int y, int w, int h,
                                         int flags, bool enabled, const QPixmap *pixmap,
                                         const QString& text, int len=-1);

Q_GUI_EXPORT QT3_SUPPORT void qDrawItem(QPainter *p, Qt::GUIStyle gs, int x, int y, int w, int h,
                                        int flags, const QPalette &pal, bool enabled,
                                        const QPixmap *pixmap, const QString& text,
                                        int len=-1, const QColor* penColor = 0);

Q_GUI_EXPORT QT3_SUPPORT void qDrawArrow(QPainter *p, Qt::ArrowType type, Qt::GUIStyle style,
                                         bool down, int x, int y, int w, int h,
                                         const QPalette &pal, bool enabled);
#endif

struct QTileRules {
  inline QTileRules(Qt::TileRule horizontalRule, Qt::TileRule verticalRule) :
          horizontal(horizontalRule), vertical(verticalRule) {}
  inline QTileRules(Qt::TileRule rule = Qt::StretchTile) :
          horizontal(rule), vertical(rule) {}

  Qt::TileRule horizontal;
  Qt::TileRule vertical;
};

#ifndef Q_QDOC
// For internal use only.
namespace QDrawBorderPixmap {
  enum DrawingHint {
    OpaqueTopLeft = 0x0001,
    OpaqueTop = 0x0002,
    OpaqueTopRight = 0x0004,
    OpaqueLeft = 0x0008,
    OpaqueCenter = 0x0010,
    OpaqueRight = 0x0020,
    OpaqueBottomLeft = 0x0040,
    OpaqueBottom = 0x0080,
    OpaqueBottomRight = 0x0100,
    OpaqueCorners = OpaqueTopLeft | OpaqueTopRight | OpaqueBottomLeft | OpaqueBottomRight,
    OpaqueEdges = OpaqueTop | OpaqueLeft | OpaqueRight | OpaqueBottom,
    OpaqueFrame = OpaqueCorners | OpaqueEdges,
    OpaqueAll = OpaqueCenter | OpaqueFrame
  };

  Q_DECLARE_FLAGS(DrawingHints, DrawingHint)
}
#endif

Q_GUI_EXPORT void qDrawBorderPixmap(QPainter *painter,
                                    const QRect &targetRect,
                                    const QMargins &targetMargins,
                                    const QPixmap &pixmap,
                                    const QRect &sourceRect,
                                    const QMargins &sourceMargins,
                                    const QTileRules &rules = QTileRules()
#ifndef Q_QDOC
                                    , QDrawBorderPixmap::DrawingHints hints =
                                        QDrawBorderPixmap::DrawingHints()
#endif
                                    );

inline void qDrawBorderPixmap(QPainter *painter, const QRect &target,
                              const QMargins &margins, const QPixmap &pixmap)
{
  qDrawBorderPixmap(painter, target, margins, pixmap, pixmap.rect(), margins);
}

QT_END_NAMESPACE

QT_END_HEADER

#endif // QDRAWUTIL_H
##concat##CQEnumCombo.h
#ifndef CQEnumCombo_H
#define CQEnumCombo_H

#include <QComboBox>

#if 0
#define Q_ENUM_CLASS(ENUM, NAME) \
class CQEnumComboEnum##NAME : public QObject { \
  Q_OBJECT \
\
  Q_ENUMS(ENUM) \
\
  Q_PROPERTY(ENUM value READ value WRITE setValue) \
\
 public: \
  CQEnumComboEnum##NAME() { } \
\
  ENUM value() const { return t_; } \
  void setValue(const ENUM &t) { t_ = t; }\
\
 private: \
  ENUM t_; \
};
#endif

class CQEnumCombo : public QComboBox {
  Q_OBJECT

  Q_PROPERTY(QString propName READ propName WRITE setPropName)

 public:
  CQEnumCombo(QWidget *parent, const QObject *obj=nullptr, const QString &name="");
  CQEnumCombo(const QObject *obj=nullptr, const QString &name="");

  const QObject *obj() const { return obj_; }
  void setObj(const QObject *o);

  const QString &propName() const { return propName_; }
  void setPropName(const QString &s);

  void setItemIcon(int i, const QIcon &icon);
  void setItemText(int i, const QString &text);

  void setItemData(int i, const QString &text, const QIcon &icon);

 private:
  void init();

  void updateItems();

 private slots:
  void updatePropertySlot();

 private:
  const QObject *obj_ { nullptr };
  QString        propName_;
};

#endif
##concat##CQFloatEdit.h
#ifndef CQFLOAT_EDIT_H
#define CQFLOAT_EDIT_H

#include <QLineEdit>

class CQAutoHide;

class CQFloatEdit : public QLineEdit {
  Q_OBJECT

 public:
  CQFloatEdit(QWidget *parent=0);

 ~CQFloatEdit();

  void display(const QRect &rect, const QString &text);

 private:
  bool event(QEvent *e) override;

 private slots:
  void acceptSlot();

 signals:
  void valueChanged(const QString &text);

 private:
  bool        valid_ { false };
  QString     saveText_;
  CQAutoHide *hider_ { nullptr };
};

#endif
##concat##CQFontChooser.h
#ifndef CQFontChooser_H
#define CQFontChooser_H

#include <QWidget>

class CQIconButton;
class QLineEdit;
class QPushButton;
class QToolButton;
class QLabel;
class QFontComboBox;
class QComboBox;

class CQFontChooser : public QWidget {
  Q_OBJECT

  Q_PROPERTY(QFont   font        READ font        WRITE setFont       )
  Q_PROPERTY(QString fontName    READ fontName    WRITE setFontName   )
  Q_PROPERTY(bool    fixedWidth  READ fixedWidth  WRITE setFixedWidth )
  Q_PROPERTY(QString exampleText READ exampleText WRITE setExampleText)

 public:
  enum Style {
    FontNone,
    FontEdit,
    FontButton,
    FontLabel,
    FontDetailLabel,
    FontCombo
  };

  CQFontChooser(QWidget *parent=nullptr);

  const QFont &font() const { return font_; }

  const QString &fontName() const { return fontName_; }

  bool fixedWidth() const { return fixedWidth_; }

  const QString &exampleText() const { return exampleText_; }

 public slots:
  void setStyle(Style style);

  void setFont(const QFont &font);

  void setFontName(const QString &fontName);

  void setFixedWidth(bool fixedWidth);

  void setExampleText(const QString &text);

 private:
  void updateWidgets();

  void updateCombos();

  void updateStyles();
  void updateSizes();

 private slots:
  void chooseFont();
  void editFont();
  void applyFont();
  void nameChanged();
  void styleChanged();
  void sizeChanged();

 signals:
  void fontChanged(const QFont &font);
  void fontChanged(const QString &fontName);
  void fontApplied(const QFont &font);
  void fontApplied(const QString &fontName);

 private:
  Style          style_       { FontButton };
  bool           fixedWidth_  { false };
  QFont          font_;
  QString        fontName_;
  QString        exampleText_ { "Abc" };
  QLineEdit*     cedit_       { nullptr };
  QToolButton*   cbutton_     { nullptr };
  QLabel*        clabel_      { nullptr };
  CQIconButton*  button_      { nullptr };
  QFontComboBox* ncombo_      { nullptr };
  QComboBox*     scombo_      { nullptr };
  QComboBox*     zcombo_      { nullptr };
};

#endif
##concat##CQFontDialog.h
#ifndef CQFontDialog_H
#define CQFontDialog_H

#include <QDialog>
#include <QFontDatabase>

class CQFontListView;
class QLineEdit;
class QLabel;
class QCheckBox;
class QComboBox;
class QDialogButtonBox;

class CQFontDialog : public QDialog {
  Q_OBJECT

  Q_PROPERTY(QFont             currentFont READ currentFont WRITE setCurrentFont)
  Q_PROPERTY(FontDialogOptions options     READ options     WRITE setOptions    )

 public:
  enum FontDialogOption {
    NoButtons           = (1<<0),
    DontUseNativeDialog = (1<<1),
    ScalableFonts       = (1<<2),
    NonScalableFonts    = (1<<3),
    MonospacedFonts     = (1<<4),
    ProportionalFonts   = (1<<5)
  };

  Q_ENUM(FontDialogOption)

  Q_DECLARE_FLAGS(FontDialogOptions, FontDialogOption)

 public:
  static QFont getFont(bool *ok, QWidget *parent = nullptr);
  static QFont getFont(bool *ok, const QFont &initial, QWidget *parent = nullptr,
                       const QString &title="", FontDialogOptions options=FontDialogOptions());

 public:
  CQFontDialog(QWidget *parent=0);
  CQFontDialog(const QFont &font, QWidget *parent=0);

 ~CQFontDialog();

  void setCurrentFont(const QFont &font);
  QFont currentFont() const;

  void setWritingSystem(QFontDatabase::WritingSystem ws);

  QFont selectedFont() const;

  void setOption(FontDialogOption option, bool on = true);
  bool testOption(FontDialogOption option) const;
  void setOptions(FontDialogOptions options);
  FontDialogOptions options() const;

 signals:
  void currentFontChanged(const QFont &font);
  void fontSelected(const QFont &font);

 private:
  void init();

  void initWidgets();

  void done(int result) override;

  bool eventFilter(QObject *object, QEvent *event) override;

 private slots:
  void familyHighlighted(int);
  void writingSystemHighlighted(int);
  void styleHighlighted(int);
  void sizeHighlighted(int);
  void sizeChanged(const QString &);

  void updateSample();
  void updateFamilies();
  void updateStyles();
  void updateSizes();

  void updateSampleFont(const QFont &newFont);

 private:
  QLineEdit*        familyEdit_         { nullptr };
  CQFontListView*   familyList_         { nullptr };
  QLabel*           familyAccel_        { nullptr };
  QLineEdit*        styleEdit_          { nullptr };
  CQFontListView*   styleList_          { nullptr };
  QLabel*           styleAccel_         { nullptr };
  QLineEdit*        sizeEdit_           { nullptr };
  CQFontListView*   sizeList_           { nullptr };
  QLabel*           sizeAccel_          { nullptr };
  QCheckBox*        strikeout_          { nullptr };
  QCheckBox*        underline_          { nullptr };
  QLineEdit*        sampleEdit_         { nullptr };
  QComboBox*        writingSystemCombo_ { nullptr };
  QLabel*           writingSystemAccel_ { nullptr };
  QDialogButtonBox* buttonBox_          { nullptr };

  QFontDatabase                fdb_;
  QString                      family_;
  QFontDatabase::WritingSystem writingSystem_;
  QString                      style_;
  int                          size_               { 0 };
  bool                         smoothScalable_     { false };
  QFont                        selectedFont_;
  FontDialogOptions            options_;
};

Q_DECLARE_OPERATORS_FOR_FLAGS(CQFontDialog::FontDialogOptions)

#endif
##concat##CQFontEdit.h
#ifndef CQFontEdit_H
#define CQFontEdit_H

#include <QFrame>

class CQWidgetMenu;
class QHBoxLayout;
class QLineEdit;
class QPushButton;
class QStyleOptionComboBox;
class QFontDialog;

class CQFontEdit : public QFrame {
  Q_OBJECT

  Q_PROPERTY(QFont   font     READ font       WRITE setFont    )
  Q_PROPERTY(QString fontName READ fontName   WRITE setFontName)
  Q_PROPERTY(bool    editable READ isEditable WRITE setEditable)

 public:
  CQFontEdit(QWidget *parent=nullptr);

  //---

  const QFont &font() const { return font_; }
  void setFont(const QFont &font);

  QString fontName() const { return fontName_; }
  void setFontName(const QString &fontName);

  bool isEditable() const { return editable_; }
  void setEditable(bool editable=true);

  void setNoFocus();

  //---

  QLineEdit *lineEdit() const { return edit_; }

  void paintEvent(QPaintEvent *) override;

  void resizeEvent(QResizeEvent *) override;

 private:
  friend class CQFontEditMenuButton;

  void updateEdit();

  void setNoFocusHier(QWidget *w);

  void emitFontChanged();

  void initStyle(QStyleOptionComboBox &opt);

 private slots:
  void textChangedSlot();

  void buttonSlot();

  void showMenuSlot();
  void hideMenuSlot();

  void fontSlot(const QFont &font);

  void closeMenuSlot();

 signals:
  void fontChanged(const QFont &font);
  void fontChanged(const QString &fontName);

  void menuHidden();

 private:
  bool          editable_  { true };
  QFont         font_;
  QString       fontName_;
  QLineEdit*    edit_      { nullptr }; // text edit
  QPushButton*  button_    { nullptr }; // menu button
  CQWidgetMenu* menu_      { nullptr };
  QFontDialog*  fontDlg_   { nullptr };
};

//---

#include <QLineEdit>

class CQFontEditEdit : public QLineEdit {
  Q_OBJECT

 public:
  CQFontEditEdit(CQFontEdit *edit);

  void paintEvent(QPaintEvent *) override;

 private:
  CQFontEdit *edit_ { nullptr };
};

//---

#include <QPushButton>

class CQFontEditMenuButton : public QPushButton {
  Q_OBJECT

 public:
  CQFontEditMenuButton(CQFontEdit *edit);

  void paintEvent(QPaintEvent *) override;

 private:
  CQFontEdit *edit_ { nullptr };
};

#endif
##concat##CQFont.h
#ifndef CQFONT_H
#define CQFONT_H

#ifdef CQUTIL_FONT

#include <CFont.h>

#include <QFont>

class CConfig;

#define CQFontMgrInst CQFontMgr::instance()

class CQFontMgr {
 public:
  static CQFontMgr *instance();

  static void release();

  void setPrototype();
  void resetPrototype();

  void clear();

  CFontPtr lookupFont(const QFont &qfont);

  CFontPtr lookupFont(const std::string &family, CFontStyle style, double size,
                      double angle=0, double char_angle=0, uint x_res=100, uint y_res=100);

  std::string lookupFamily(const std::string &family);

  static CFontStyle fontStyle(const QFont &qfont);

  static int getPixelSize(const QFont &qfont);

 private:
  CQFontMgr();
 ~CQFontMgr();

 private:
  CConfig *config_ { nullptr };
};

//------

class CQFont : public CFont {
 protected:
  CQFont(const std::string &family, CFontStyle style, double size, double angle=0,
         double char_angle=0, int x_res=100, int y_res=100);

  explicit CQFont(const std::string &full_name);

  virtual ~CQFont();

  CFontPtr dup(const std::string &family, CFontStyle style, double size, double angle=0,
               double char_angle=0, int x_res=100, int y_res=100) const;

 private:
  CQFont(const CFont &qfont);
  CQFont(const QFont &qfont);
  CQFont(const CQFont &qfont);

  CQFont &operator=(const CFont &qfont);
  CQFont &operator=(const CQFont &qfont);

 public:
  const QFont &getQFont() const { return *qfont_; }

  double getCharWidth () const;
  double getCharAscent() const;
  double getCharDescent() const;
  double getCharHeight() const;

  double getStringWidth(const std::string &str) const;

  bool isProportional() const;

  CImagePtr getStringImage(const std::string &str);

 private:
  friend class CQFontMgr;

  QFont *qfont_ { 0 };
};

#endif

#endif
##concat##CQFontListView.h
#ifndef CQFontListView_H
#define CQFontListView_H

#include <QListView>
#include <QStringListModel>

class CQFontListView : public QListView {
  Q_OBJECT

 public:
  CQFontListView(QWidget *parent=0);

 ~CQFontListView();

  QStringListModel *model() const {
    return static_cast<QStringListModel *>(QListView::model());
  }

  void setCurrentItem(int item) {
     QListView::setCurrentIndex(static_cast<QAbstractListModel*>(model())->index(item));
  }

  int currentItem() const {
    return QListView::currentIndex().row();
  }

  int count() const {
    return model()->rowCount();
  }

  QString currentText() const {
    int row = QListView::currentIndex().row();
    return row < 0 ? QString() : model()->stringList().at(row);
  }

  void currentChanged(const QModelIndex &current, const QModelIndex &previous) Q_DECL_OVERRIDE {
    QListView::currentChanged(current, previous);

    if (current.isValid())
      emit highlighted(current.row());
  }

  QString text(int i) const {
    return model()->stringList().at(i);
  }

 signals:
  void highlighted(int);

 private:
  QStringListModel *model_ { nullptr };
};

#endif
##concat##CQFontUtil.h
#ifndef CQFontUtil_H
#define CQFontUtil_H

#ifdef CQUTIL_FONT
#include <CFontPtr.h>
#endif

#include <QFont>

namespace CQFontUtil {

#ifdef CQUTIL_FONT
QFont    toQFont  (CFontPtr font);
CFontPtr fromQFont(QFont font);
#endif

}

#endif
##concat##CQGroupBox.h
#ifndef CQGroupBox_H
#define CQGroupBox_H

#include <QWidget>

class CQGroupBoxArea;

/*!
 * \brief Custom groupbox supporting custom title and line drawing and collapse
 */
class CQGroupBox : public QWidget {
  Q_OBJECT

  // title
  Q_PROPERTY(QString       title          READ title          WRITE setTitle         )
  Q_PROPERTY(bool          titleBold      READ isTitleBold    WRITE setTitleBold     )
  Q_PROPERTY(double        titleScale     READ titleScale     WRITE setTitleScale    )
  Q_PROPERTY(bool          titleColored   READ isTitleColored WRITE setTitleColored  )
  Q_PROPERTY(Qt::Alignment titleAlignment READ titleAlignment WRITE setTitleAlignment)

  // line top/bottom
  Q_PROPERTY(bool          lineTop
             READ hasLineTop          WRITE setHasLineTop         )
  Q_PROPERTY(bool          lineBottom
             READ hasLineBottom       WRITE setHasLineBottom      )
  Q_PROPERTY(Qt::Alignment lineTopAlignment
             READ lineTopAlignment    WRITE setLineTopAlignment   )
  Q_PROPERTY(Qt::Alignment lineBottomAlignment
             READ lineBottomAlignment WRITE setLineBottomAlignment)
  // margins
  Q_PROPERTY(int marginLeft   READ marginLeft   WRITE setMarginLeft  )
  Q_PROPERTY(int marginRight  READ marginRight  WRITE setMarginRight )
  Q_PROPERTY(int marginBottom READ marginBottom WRITE setMarginBottom)
  Q_PROPERTY(int marginTop    READ marginTop    WRITE setMarginTop   )

  // check
  Q_PROPERTY(bool checkable     READ isCheckable     WRITE setCheckable    )
  Q_PROPERTY(bool checked       READ isChecked       WRITE setChecked      )
  Q_PROPERTY(bool enableChecked READ isEnableChecked WRITE setEnableChecked)

  // collapse
  Q_PROPERTY(bool collapsible READ isCollapsible WRITE setCollapsible)
  Q_PROPERTY(bool collapsed   READ isCollapsed   WRITE setCollapsed  )

 public:
  CQGroupBox(QWidget *parent=nullptr);
  CQGroupBox(const QString &title, QWidget *parent=nullptr);

  ~CQGroupBox();

  //---

  const QString &title() const { return title_; }
  void setTitle(const QString &title);

  bool isTitleBold() const { return titleBold_; }
  void setTitleBold(bool bold);

  double titleScale() const { return titleScale_; }
  void setTitleScale(double scale);

  bool isTitleColored() const { return titleColored_; }
  void setTitleColored(bool b);

  Qt::Alignment titleAlignment() const { return titleAlignment_; }
  void setTitleAlignment(Qt::Alignment alignment);

  //---

  bool hasLineTop() const { return lineTop_; }
  void setHasLineTop(bool line);

  bool hasLineBottom() const { return lineBottom_; }
  void setHasLineBottom(bool line);

  Qt::Alignment lineTopAlignment() const { return lineTopAlignment_; }
  void setLineTopAlignment(Qt::Alignment alignment);

  Qt::Alignment lineBottomAlignment() const { return lineBottomAlignment_; }
  void setLineBottomAlignment(Qt::Alignment alignment);

  //---

  int marginLeft() const { return marginLeft_; }
  void setMarginLeft(int margin);

  int marginRight() const { return marginRight_; }
  void setMarginRight(int margin);

  int marginBottom() const { return marginBottom_; }
  void setMarginBottom(int margin);

  int marginTop() const { return marginTop_; }
  void setMarginTop(int margin);

  //---

  bool isCheckable() const { return checkable_; }
  void setCheckable(bool checkable);

  bool isChecked() const { return checked_; }

  bool isEnableChecked() const { return enableChecked_; }
  void setEnableChecked(bool b);

  //---

  bool isCollapsible() const { return collapsible_; }
  void setCollapsible(bool collapsible);

  bool isCollapsed() const { return collapsed_; }

  //---

  QWidget *cornerwidget() const { return cornerWidget_; }
  void setCornerWidget(QWidget *w);

  //---

  QSize sizeHint() const override;
  QSize minimumSizeHint() const override;

 private:
  void init();

  void setTitleFont();

  void changeEvent(QEvent *e) override;

  void childEvent(QChildEvent *e) override;

  bool event(QEvent *e) override;

  void focusInEvent(QFocusEvent *e) override;

  void leaveEvent(QEvent *) override;
  void enterEvent(QEvent *) override;

  void mouseMoveEvent   (QMouseEvent *e) override;
  void mousePressEvent  (QMouseEvent *e) override;
  void mouseReleaseEvent(QMouseEvent *e) override;

  void paintEvent(QPaintEvent *e) override;

  void drawArcShape(QPainter *painter, double xc, double yc, double r,
                    double startAngle, int sides) const;

  void resizeEvent(QResizeEvent *e) override;

  int spaceTop() const;
  int spaceBottom() const;

  void calculateFrame();

  void updateEnabled();
  void updateCollapsed();

 signals:
  void clicked(bool checked);
  void toggled(bool checked);

  void collapse(bool collapsed);

 public slots:
  void setChecked(bool checked);
  void setCollapsed(bool collapsed);

 private slots:
  void updateSlot();

 private:
//CQGroupBoxArea *area_ { nullptr };

  // title
  QString       title_;
  bool          titleBold_      { true };
  double        titleScale_     { 1.0 };
  bool          titleColored_   { false };
  Qt::Alignment titleAlignment_ { Qt::AlignLeft | Qt::AlignBottom };
  QRect         titleRect_;
  QFont         titleFont_;

  // underline
  bool          lineTop_             { false };
  bool          lineBottom_          { true };
  Qt::Alignment lineTopAlignment_    { Qt::AlignBottom };
  Qt::Alignment lineBottomAlignment_ { Qt::AlignVCenter };
  QColor        lineColor_;

  // margins
  int marginLeft_   { 6 };
  int marginRight_  { 2 };
  int marginBottom_ { -1 };
  int marginTop_    { -1 };

  // check
  bool  checkable_     { false };
  bool  checked_       { false };
  bool  enableChecked_ { true };
  bool  checkPress_    { false };
  QRect checkRect_;

  // collapse
  bool  collapsible_   { false };
  bool  collapsed_     { false };
  bool  collapsePress_ { false };
  QRect collapseRect_;

  bool pressed_        { false };
  bool insideCheck_    { false };
  bool insideCollapse_ { false };

  int dx_ { 2 }; // title/line x margin
//int dy_ { 2 };

  // corner widget
  QWidget* cornerWidget_ { nullptr };
};

//----

#if 0
class CQGroupBoxArea : public QWidget {
 public:
  CQGroupBoxArea(QWidget *parent=0);

  void paintEvent(QPaintEvent *e) override;
};
#endif

#endif
##concat##CQHeaderView.h
#ifndef CQHeaderView_H
#define CQHeaderView_H

#include <QHeaderView>

class CQHeaderViewWidgetFactory;
class QTableView;
class QTreeView;
class QSortFilterProxyModel;

class CQHeaderView : public QHeaderView {
  Q_OBJECT

  Q_PROPERTY(bool initFit READ isInitFit WRITE setInitFit)

 public:
  CQHeaderView(QWidget *parent=nullptr);

  bool isInitFit() const { return initFit_; }
  void setInitFit(bool b) { initFit_ = b; }

  void setWidgetFactory(CQHeaderViewWidgetFactory *factory);

  void setSectionsMovable(bool movable);
  void setSectionsClickable(bool clickable);

  QWidget *widget(int i) const;

  void initWidgets();

  void fixWidgetPositions();

  void update();

 private:
  void doInitFit();

  void contextMenuEvent(QContextMenuEvent *event) override;

  void showEvent(QShowEvent *e) override;

  void resizeEvent(QResizeEvent *e) override;

 public slots:
  void fitAllSlot();

 private slots:
  void handleSectionResized(int section, int oldSize, int newSize);

  void handleSectionMoved(int logical, int oldVisualIndex, int newVisualIndex);

  void handleSectionClicked(int logical);

  void fitColumnSlot();

  void stretchLastSlot(bool b);
  void sortIndicatorSlot(bool b);

  void resetSortSlot();

  void sortIncreasingSlot();
  void sortDecreasingSlot();

 private:
  typedef std::map<int, int> ColumnWidths;

  void calcTableWidths(QTableView *table, ColumnWidths &columnWidths);

  void calcTreeWidths(QTreeView *tree, const QModelIndex &ind,
                      int depth, ColumnWidths &columnWidths);

  QSortFilterProxyModel *proxyModel();

 private:
  typedef QList<QWidget *> Widgets;

  CQHeaderViewWidgetFactory *factory_     { nullptr };
  Widgets                    widgets_;
  int                        menuSection_ { -1 };
  int                        sortRole_    { -1 };
  bool                       shown_       { false };
  bool                       resized_     { false };
  bool                       initFit_     { false };
};

//---

class CQHeaderViewWidgetFactory {
 public:
  CQHeaderViewWidgetFactory() { }

  virtual ~CQHeaderViewWidgetFactory() { }

  virtual QWidget *createWidget(int i) = 0;
};

#endif
##concat##CQIconButton.h
#ifndef CQIconButton_H
#define CQIconButton_H

#include <QToolButton>

class CQIconButton : public QToolButton {
  Q_OBJECT

  Q_PROPERTY(QString iconName READ icon WRITE setIcon)
  Q_PROPERTY(Size    size     READ size WRITE setSize)

  Q_ENUMS(Size)

 public:
  enum class Size {
    NORMAL,
    SMALL,
    LARGE
  };

 public:
  CQIconButton(QWidget *parent=nullptr);
  CQIconButton(const QString &iconName, QWidget *parent=nullptr);

  const Size &size() const { return size_; }
  void setSize(const Size &s);

  const QString &icon() const { return iconName_; }
  void setIcon(const QString &iconName);

  QIcon qicon() const;

 private slots:
  void init();

  void updateIcon();

 private:
  QString iconName_;
  Size    size_ { Size::NORMAL };
};

#endif
##concat##CQIconCombo.h
#ifndef CQIconCombo_H
#define CQIconCombo_H

#include <QComboBox>

class CQIconComboModel;

class CQIconCombo : public QComboBox {
  Q_OBJECT

  Q_PROPERTY(int iconWidth     READ iconWidth     WRITE setIconWidth)
  Q_PROPERTY(int menuTextWidth READ menuTextWidth WRITE setMenuTextWidth)

 public:
  CQIconCombo(QWidget *parent=nullptr);
 ~CQIconCombo();

  int iconWidth() const { return iconWidth_; }
  void setIconWidth(int i) { iconWidth_ = i; }

  int menuTextWidth() const { return textWidth_; }
  void setMenuTextWidth(int w);

  void addItem(const QIcon &icon, const QString &str, const QVariant &var=QVariant());

  QVariant itemData(int ind) const;

  QSize sizeHint() const;
  QSize minimumSizeHint() const;

  void paintEvent(QPaintEvent *e);

 private slots:
  void updateTip();

 protected:
  void showPopup();

  void calcMenuTextWidth();

 private:
  CQIconComboModel *model_     { nullptr };
  int               iconWidth_ { -1 };
  int               textWidth_ { -1 };
};

#endif
##concat##CQIconLabel.h
#ifndef CQIconLabel_H
#define CQIconLabel_H

#include <QLabel>

class CQIconLabel : public QLabel {
  Q_OBJECT

  Q_PROPERTY(Size size READ size WRITE setSize)

  Q_ENUMS(Size)

 public:
  enum class Size {
    NORMAL,
    SMALL,
    LARGE
  };

 public:
  CQIconLabel(QWidget *parent=nullptr);

  const Size &size() const { return size_; }
  void setSize(const Size &s);

  void setIcon(const QString &iconName);

 private slots:
  void updateIcon();

 private:
  QString iconName_;
  Size    size_ { Size::NORMAL };
};

#endif
##concat##CQIconRadio.h
#ifndef CQIconRadio_H
#define CQIconRadio_H

#include <QRadioButton>

class CQIconRadio : public QRadioButton {
  Q_OBJECT

  Q_PROPERTY(Size size READ size WRITE setSize)

  Q_ENUMS(Size)

 public:
  enum class Size {
    NORMAL,
    SMALL,
    LARGE
  };

 public:
  CQIconRadio(QWidget *parent=nullptr);

  const Size &size() const { return size_; }
  void setSize(const Size &s);

  void setIcon(const QString &iconName);

 private slots:
  void updateIcon();

 private:
  QString iconName_;
  Size    size_ { Size::NORMAL };
};

#endif
##concat##CQImageButton.h
#ifndef CQIMAGE_BUTTON_H
#define CQIMAGE_BUTTON_H

#include <QToolButton>
#include <CImageLib.h>

class CQImageButton : public QToolButton {
  Q_OBJECT

 public:
#ifdef CQUTIL_IMAGE
  CQImageButton(CImagePtr image);
#endif
  CQImageButton(const QString &fileName);
  CQImageButton(uchar *data, uint len);
  CQImageButton(const QPixmap &pixmap);
  CQImageButton(const QIcon &icon);

  virtual ~CQImageButton() { }

  QSize sizeHint() const override;
  QSize minimumSizeHint() const override;

 private:
#ifdef CQUTIL_IMAGE
  void init(CImagePtr image);
#endif
  void init(const QPixmap &pixmap);
  void init(const QIcon &icon);

 private:
  QSize size_;
};

#endif
##concat##CQImageGaussianBlur.h
#ifndef CQIMAGE_GAUSSIAN_BLUR_H
#define CQIMAGE_GAUSSIAN_BLUR_H

#include <QImage>
#include <CGaussianBlur.h>

class CQImageWrapper {
 public:
  explicit CQImageWrapper(QImage &image) :
   image_(image) {
    px1_ = 0; px2_ = image_.width () - 1;
    py1_ = 0; py2_ = image_.height() - 1;

    wx1_ = px1_; wy1_ = py1_;
    wx2_ = px2_; wy2_ = py2_;
  }

  void getPixelRange(int *x1, int *y1, int *x2, int *y2) const {
    *x1 = px1_; *y1 = py1_;
    *x2 = px2_; *y2 = py2_;
  }

  void getWindow(int *x1, int *y1, int *x2, int *y2) const {
    *x1 = wx1_; *y1 = wy1_;
    *x2 = wx2_; *y2 = wy2_;
  }

  void setWindow(int x1, int y1, int x2, int y2) {
    wx1_ = x1; wy1_ = y1;
    wx2_ = x2; wy2_ = y2;
  }

  void getRGBA(int x, int y, double *r, double *g, double *b, double *a) const {
    QRgb rgb = image_.pixel(x, y);

    *r = qRed  (rgb)/255.0;
    *g = qGreen(rgb)/255.0;
    *b = qBlue (rgb)/255.0;
    *a = qAlpha(rgb)/255.0;
  }

  void setRGBA(int x, int y, double r, double g, double b, double a) {
    QRgb rgb = qRgba(int(r*255), int(g*255), int(b*255), int(a*255));

    image_.setPixel(x, y, rgb);
  }

 private:
  friend class CQImageGaussianBlur;

  QImage &image_;
  int     px1_, py1_, px2_, py2_;
  int     wx1_, wy1_, wx2_, wy2_;
};

//---

class CQImageGaussianBlur {
 public:
  explicit CQImageGaussianBlur(const QImage &src) :
   src_(src), wsrc_(src_) {
  }

  void setWindow(int x1, int y1, int x2, int y2) {
    wsrc_.setWindow(x1, y1, x2, y2);
  }

  bool blur(QImage &dst, double bx=1, double by=1, int nx=0, int ny=0) {
    if (dst.isNull()) {
      int iw = src_.width ();
      int ih = src_.height();

      dst = QImage(iw, ih, QImage::Format_ARGB32);

      dst.fill(qRgba(0, 0, 0, 0));
    }

    CGaussianBlur<CQImageWrapper> blur;

    CQImageWrapper wdst(dst);

    return blur.blur(wsrc_, wdst, bx, by, nx, ny);
  }

 private:
  QImage         src_;
  CQImageWrapper wsrc_;
};

#endif
##concat##CQImage.h
#ifndef CQ_IMAGE_H
#define CQ_IMAGE_H

#ifdef CQUTIL_IMAGE

#include <QImage>

#include <CImage.h>

/* Qt override for CImage to allow procesing either QImage or CImage data
   and sync the two when needed */

class CQImage : public CImage {
  // Create
 protected:
  CQImage();

  CQImage(int width, int height);

  CQImage(const CImage &image);

  explicit CQImage(const QImage &image);

 public:
  static void setPrototype();
  static void resetPrototype();

 public:
  CQImage(const CQImage &qimage);
 ~CQImage();

  CQImage &operator=(const QImage &image);

  void setImage(const QImage &image);

 protected:
  CQImage &operator=(const CImage &image);
  CQImage &operator=(const CQImage &image);

 public:
  CImagePtr dup() const;

  void updateCImage();

  QImage &getQImage();
  QImage *getQImageP();

  //------

  void setDataSizeV(int width, int height);

  bool setColorIndexPixel(int pos, uint pixel);
  bool setColorIndexPixel(int x, int y, uint pixel);

  bool setRGBAPixel(int pos, const CRGBA &rgba);
  bool setRGBAPixel(int x, int y, const CRGBA &rgba);

  //------

  void dataChanged();

 public:
  bool gaussianBlurExec(CImagePtr &dst, double bx, double by, int nx, int ny);

 private:
  void initQImage();

 private:
  QImage qimage_;
  bool   initialized_ { false };
};

#endif

#endif
##concat##CQImageUtil.h
#ifndef CQImageUtil_H
#define CQImageUtil_H

#ifdef CQUTIL_IMAGE
#include <CImagePtr.h>
#endif

#include <QIcon>

namespace CQImageUtil {
#ifdef CQUTIL_IMAGE
  QIcon imageToIcon(CImagePtr image);

  QImage toQImage(CImagePtr image);
#endif
}

#endif
##concat##CQIntegerEdit.h
#ifndef CQINTEGER_EDIT_H
#define CQINTEGER_EDIT_H

#include <QLineEdit>

class CQIntegerEdit : public QLineEdit {
  Q_OBJECT

 public:
  CQIntegerEdit(QWidget *parent, int value=0);
  CQIntegerEdit(int value=0);

  virtual ~CQIntegerEdit() { }

  int getValue() const;
  void setValue(int value);

 private:
  void init(const QString &name, int value);

 private slots:
  void editingFinishedI();

 signals:
  void valueChanged(int);

 private:
  void valueToWidget();
  bool widgetToValue();

 private:
  int value_ { 0 };
};

#endif
##concat##CQIntegerSpin.h
#ifndef CQINTEGER_SPIN_H
#define CQINTEGER_SPIN_H

#include <QSpinBox>

class CQIntegerSpin : public QSpinBox {
  Q_OBJECT

  Q_PROPERTY(bool autoStep READ isAutoStep WRITE setAutoStep)
  Q_PROPERTY(int  step     READ step)

 public:
  CQIntegerSpin(QWidget *parent, int value=0);
  CQIntegerSpin(int value=0);

  virtual ~CQIntegerSpin() { }

  bool isAutoStep() const { return autoStep_; }
  void setAutoStep(bool b) { autoStep_ = b; }

  int cursorPosition() const;
  void setCursorPosition(int pos);

  int step() const { return step_; }

  void stepBy(int n);

 signals:
  void stepChanged(int);

 private slots:
  void updateStep();

 private:
  void init(int value);

  int posToStep(int pos) const;

  bool isNegative() const;

 private:
  bool autoStep_ { true };
  int  step_     { 1 };
};

#endif
##concat##CQLabel.h
#ifndef CQLABEL_H
#define CQLABEL_H

#include <QLabel>
#include <QVariant>

/*!
 * \brief label widget supporting horizontal or vertical text
 */
class CQLabel : public QLabel {
 public:
  Q_PROPERTY(QVariant        value       READ value       WRITE setValue      )
  Q_PROPERTY(Qt::Orientation orientation READ orientation WRITE setOrientation)

 public:
  CQLabel(const QVariant &value=QVariant(), QWidget *parent=nullptr);
  CQLabel(const QVariant &value, Qt::Orientation orient, QWidget *parent=nullptr);

  virtual ~CQLabel() { }

  const QVariant &value() const { return value_; }
  void setValue(const QVariant &v);

  Qt::Orientation orientation() const { return orientation_; }
  void setOrientation(Qt::Orientation orient);

  QSize sizeHint() const override;
  QSize minimumSizeHint() const override;

 protected:
  void paintEvent(QPaintEvent *e) override;

 private:
  void updateState();

 private:
  QVariant        value_;
  Qt::Orientation orientation_ { Qt::Horizontal };
};

#endif
##concat##CQLineDash.h
#ifndef CQLINE_DASH_H
#define CQLINE_DASH_H

#include <QFrame>
#include <QAction>
#include <CLineDash.h>
#include <map>

class QMenu;
class QLineEdit;
class QToolButton;
class CQIconCombo;
class CQLineDashAction;

class CQLineDash : public QFrame {
  Q_OBJECT

  Q_PROPERTY(bool editable READ editable WRITE setEditable)

 public:
  CQLineDash(QWidget *parent=0);

  bool editable() const { return editable_; }
  void setEditable(bool b);

  void setLineDash(const CLineDash &dash);
  const CLineDash &getLineDash() const { return dash_; }

  void addDashOption(const std::string &id, const CLineDash &dash);

  static QIcon dashIcon(const CLineDash &dash);

 private:
  void updateState();

 private slots:
  void dashChangedSlot();
  void menuItemActivated(QAction *);
  void comboItemChanged();

 signals:
  void valueChanged(const CLineDash &dash);

 private:
  typedef std::map<std::string, CQLineDashAction *> Actions;

  bool         editable_;
  CLineDash    dash_;
  QLineEdit   *edit_;
  QToolButton *button_;
  QMenu       *menu_;
  CQIconCombo *combo_;
  Actions      actions_;
};

class CQLineDashAction : public QAction {
 public:
  CQLineDashAction(CQLineDash *parent, const std::string &id,
                   const CLineDash &dash, const QIcon &icon);

 private:
  void init();

 private:
  CQLineDash  *parent_;
  std::string  id_;
  CLineDash    dash_;
};

#endif
##concat##CQLineEdit.h
#ifndef CQLineEdit_H
#define CQLineEdit_H

#include <QLineEdit>

/*!
 * Simple wrapper around QLineEdit to support colored placeholder text
*/
class CQLineEdit : public QLineEdit {
  Q_OBJECT

  Q_PROPERTY(QColor placeholderColor  READ placeholderColor  WRITE setPlaceholderColor )
  Q_PROPERTY(bool   placeholderItalic READ placeholderItalic WRITE setPlaceholderItalic)

 private:
  enum State {
    STATE_NONE,
    STATE_NORMAL,
    STATE_PLACE
  };

 public:
  //! create widget
  CQLineEdit(QWidget *parent=0);

  //! get placeholder text color
  const QColor &placeholderColor() const { return placeColor_; }
  //! set placeholder text color
  void setPlaceholderColor(const QColor &color);

  //! get placeholder is italic
  bool placeholderItalic() const { return placeItalic_; }
  //! set placeholder is italic
  void setPlaceholderItalic(bool italic);

 private slots:
  //! update placeholder style state
  void updateState(bool force=false);

 private:
  //! update style sheet
  void updateStyle();

  //! get stylesheet color string from color
  static QString colorString(const QColor &color);

 protected:
  //! handle focus in event
  void focusInEvent(QFocusEvent *e) override;

  //! handle focus out event
  void focusOutEvent(QFocusEvent *e) override;

  //! handle change event
  void changeEvent(QEvent *e) override;

 private:
  QColor placeColor_;  //!< placeholder text color
  bool   placeItalic_; //!< placeholder is italic
  State  state_;       //!< current placeholder style state
  bool   ignore_;      //!< ignore events
};

#endif
##concat##CQMainWindow.h
#ifndef CQMAIN_WINDOW_H
#define CQMAIN_WINDOW_H

#include <QMainWindow>

class CQMainWindow : public QMainWindow {
  Q_OBJECT

 public:
  explicit CQMainWindow(const QString &title="");

  virtual ~CQMainWindow() { }

  void init();

 protected:
  virtual QWidget *createCentralWidget() { return nullptr; }

  virtual void createWorkspace() { }
  virtual void createMenus() { }
  virtual void createToolBars() { }
  virtual void createStatusBar() { }
  virtual void createDockWindows() { }

  virtual void initTerm() { }

 private:
  QString title_;
};

#endif
##concat##CQMdiArea.h
#ifndef CQMdiArea_H
#define CQMdiArea_H

#include <QObject>
#include <QMdiArea>
#include <QMdiSubWindow>
#include <QSignalMapper>

#include <CQMenu.h>

class CQMdiAreaUpdateWindowsMenuIFace {
 public:
  virtual ~CQMdiAreaUpdateWindowsMenuIFace() { }

  virtual void exec() = 0;
};

template<typename W>
class CQMdiArea;

template<typename W>
class CQMdiAreaUpdateWindowsMenu : public CQMdiAreaUpdateWindowsMenuIFace {
 public:
  CQMdiAreaUpdateWindowsMenu(CQMdiArea<W> *area) :
   area_(area) {
  }

  void exec();

 private:
  CQMdiArea<W> *area_;
};

class CQMdiAreaUpdateWindowsMenuObject : public QObject {
  Q_OBJECT

 private:
  CQMdiAreaUpdateWindowsMenuIFace *iface_;

 public:
  CQMdiAreaUpdateWindowsMenuObject(CQMenu *menu, CQMdiAreaUpdateWindowsMenuIFace *iface);

 private slots:
  void updateWindowsMenu();
};

template<typename W>
class CQMdiArea {
 public:
  typedef QList<W *> WindowList;

 public:
  CQMdiArea(QMainWindow *mainWindow, const QString &name) :
   mainWindow_(mainWindow) {
    area_ = new QMdiArea;

    area_->setObjectName(name);

    mainWindow_->setCentralWidget(area_);

    windowMapper_ = new QSignalMapper(mainWindow_);

//  QObject::connect(windowMapper_, SIGNAL(mapped(QWidget *)),
//                   area_, SLOT(setActiveSubWindow(QMdiSubWindow *)));
  }

  virtual ~CQMdiArea() { }

  QMainWindow *getMainWindow() const { return mainWindow_; }

  QMdiArea *getArea() const { return area_; }

  QSignalMapper *getMapper() const { return windowMapper_; }

  W *addWindow(const QString &name) {
    W *w = new W(mainWindow_);

    w->setObjectName(name);

    w->setWindowTitle(name);

    w->setAttribute(Qt::WA_DeleteOnClose);

    QMdiSubWindow *window = area_->addSubWindow(w);

    window->show();

    return w;
  }

  W *getWindow(uint i) const {
    const WindowList &windows = windowList();

    return windows.at(i);
  }

  int getNumWindows() const {
    const WindowList &windows = windowList();

    return windows.size();
  }

  W *activeWindow() const {
    return dynamic_cast<W *>(area_->activeSubWindow()->widget());
  }

  const WindowList &windowList() const {
    CQMdiArea *th = const_cast<CQMdiArea *>(this);

    QList<QMdiSubWindow *> widgets = area_->subWindowList();

    auto p1 = widgets.begin();
    auto p2 = widgets.end  ();

    th->windows_.clear();

    for ( ; p1 != p2; ++p1) {
      QMdiSubWindow *window = *p1;

      th->windows_.push_back(static_cast<W *>(window->widget()));
    }

    return windows_;
  }

  void updateWindowsMenu() {
    QMenu *menu = windowsMenu_->getMenu();

    menu->clear();

    menu->addAction(closeItem_->getAction());
    menu->addAction(closeAllItem_->getAction());
    menu->addSeparator();

    menu->addAction(tileItem_->getAction());
    menu->addAction(cascadeItem_->getAction());
    menu->addAction(arrangeItem_->getAction());

    menu->addSeparator();

    menu->addAction(nextItem_->getAction());
    menu->addAction(prevItem_->getAction());

    WindowList windows = windowList();

    if (! windows.isEmpty()) {
      menu->addSeparator();

      W *current = activeWindow();

      for (int i = 0; i < windows.size(); ++i) {
        W *window = windows.at(i);

        QAction *action = menu->addAction(window->objectName());

        action->setCheckable(true);

        action->setChecked(window == current);

        QObject::connect(action, SIGNAL(triggered()), windowMapper_, SLOT(map()));

        windowMapper_->setMapping(action, window);
      }
    }
  }

  CQMenu *addWindowsMenu() {
    windowsMenu_ = new CQMenu(mainWindow_, "&Windows");

    closeItem_ = new CQMenuItem(windowsMenu_, "Cl&ose");

    closeItem_->setShortcut("Ctrl+F4");
    closeItem_->setStatusTip("Close the active window");

    QObject::connect(closeItem_->getAction(), SIGNAL(triggered()),
                     area_, SLOT(closeActiveSubWindow()));

    closeAllItem_ = new CQMenuItem(windowsMenu_, "Close &All");

    closeAllItem_->setStatusTip("Close all the windows");

    QObject::connect(closeAllItem_->getAction(), SIGNAL(triggered()),
                     area_, SLOT(closeAllSubWindows()));

    tileItem_ = new CQMenuItem(windowsMenu_, "&Tile");

    tileItem_->setStatusTip("Tile the windows");

    QObject::connect(tileItem_->getAction(), SIGNAL(triggered()),
                     area_, SLOT(tileSubWindows()));

    cascadeItem_ = new CQMenuItem(windowsMenu_, "&Cascade");

    cascadeItem_->setStatusTip("Cascade the windows");

    QObject::connect(cascadeItem_->getAction(), SIGNAL(triggered()),
                     area_, SLOT(cascadeSubWindows()));

    arrangeItem_ = new CQMenuItem(windowsMenu_, "Arrange &icons");

    arrangeItem_->setStatusTip("Arrange the icons");

    QObject::connect(arrangeItem_->getAction(), SIGNAL(triggered()),
                     area_, SLOT(arrangeIcons()));

    nextItem_ = new CQMenuItem(windowsMenu_, "Ne&xt");

    nextItem_->setStatusTip("Move the focus to the next window");

    QObject::connect(nextItem_->getAction(), SIGNAL(triggered()),
                     area_, SLOT(activateNextSubWindow()));

    prevItem_ = new CQMenuItem(windowsMenu_, "Pre&vious");

    prevItem_->setStatusTip("Move the focus to the prev window");

    QObject::connect(prevItem_->getAction(), SIGNAL(triggered()),
                     area_, SLOT(activatePreviousSubWindow()));

    //------

    CQMdiAreaUpdateWindowsMenu<W> *update =
      new CQMdiAreaUpdateWindowsMenu<W>(this);

    new CQMdiAreaUpdateWindowsMenuObject(windowsMenu_, update);

    return windowsMenu_;
  }

 private:
  QMainWindow   *mainWindow_;
  QMdiArea      *area_;
  WindowList     windows_;
  QSignalMapper *windowMapper_;
  CQMenu        *windowsMenu_;
  CQMenuItem    *closeItem_;
  CQMenuItem    *closeAllItem_;
  CQMenuItem    *tileItem_;
  CQMenuItem    *cascadeItem_;
  CQMenuItem    *arrangeItem_;
  CQMenuItem    *nextItem_;
  CQMenuItem    *prevItem_;
  CQMenuItem    *separatorItem_;
};

template<typename W>
void
CQMdiAreaUpdateWindowsMenu<W>::
exec() {
  area_->updateWindowsMenu();
}

#endif
##concat##CQMenu.h
#ifndef CQMENU_H
#define CQMENU_H

#include <QMenu>
#include <QAction>
#include <QMainWindow>
#include <QMenuBar>

#include <map>

class CQMenuItem;

class CQMenu {
 public:
  CQMenu(QMainWindow *mainWindow, const QString &name) :
   mainWindow_(mainWindow) {
    if (name == "|")
      mainWindow->menuBar()->addSeparator();
    else
      menu_ = mainWindow->menuBar()->addMenu(name);
  }

  CQMenu(QWidget *widget, const QString &name="") {
    menu_ = new QMenu(widget);

    if (name.length())
      menu_->setObjectName(name);
  }

  QMainWindow *getMainWindow() const { return mainWindow_; }

  QWidget *getParent() const {
    return (mainWindow_ ? mainWindow_ : menu_->parentWidget());
  }

  QMenu *getMenu() const { return menu_; }

  void startGroup() {
    actionGroup_ = new QActionGroup(mainWindow_);
  }

  void endGroup() {
    actionGroup_ = nullptr;
  }

  void addMenuItem(CQMenuItem *menuItem);

  void addAction(QAction *action) {
    if (actionGroup_)
      actionGroup_->addAction(action);

    menu_->addAction(action);

    actionMap_[action->text()] = action;
  }

  CQMenuItem *getMenuItem(const QString &name) {
    auto p = menuItemMap_.find(name);

    if (p != menuItemMap_.end())
      return (*p).second;

    return nullptr;
  }

  QAction *getAction(const QString &name) {
    auto p = actionMap_.find(name);

    if (p != actionMap_.end())
      return (*p).second;

    return nullptr;
  }

  void addSeparator() {
    menu_->addSeparator();
  }

  void exec(const QPoint &pos) {
    (void) menu_->exec(pos);
  }

 private:
  typedef std::map<QString, CQMenuItem *> MenuItemMap;
  typedef std::map<QString, QAction *>    ActionMap;

  QMainWindow  *mainWindow_ { nullptr };
  QMenu        *menu_ { nullptr };
  QActionGroup *actionGroup_ { nullptr };
  MenuItemMap   menuItemMap_;
  ActionMap     actionMap_;
};

//------

class CQMenuItem {
 public:
  enum Type {
    NORMAL    = 0,
    CHECKABLE = (1<<0),
    CHECKED   = (1<<1)
  };

  CQMenuItem(CQMenu *menu, const QString &name, Type type = NORMAL) :
   menu_(menu) {
    action_ = new QAction(name, menu->getParent());

    menu_->addMenuItem(this);

    if ((type & CHECKABLE) || (type & CHECKED))
      setCheckable(true);

    if (type & CHECKED)
      setChecked(true);
  }

  CQMenuItem(CQMenu *menu, const QIcon &icon, const QString &name, Type type = NORMAL) :
   menu_(menu) {
    action_ = new QAction(icon, name, menu->getParent());

    menu_->addMenuItem(this);

    if ((type & CHECKABLE) || (type & CHECKED))
      setCheckable(true);

    if (type & CHECKED)
      setChecked(true);
  }

  CQMenuItem(CQMenu *menu, const QString &name, const QIcon &icon, Type type = NORMAL) :
   menu_(menu) {
    action_ = new QAction(icon, name, menu->getParent());

    menu_->addMenuItem(this);

    if ((type & CHECKABLE) || (type & CHECKED))
      setCheckable(true);

    if (type & CHECKED)
      setChecked(true);
  }

  QString getName() const { return action_->text(); }

  void setName(const std::string &name) { action_->setText(name.c_str()); }

  QAction *getAction() const { return action_; }

  void setShortcut(const QKeySequence &key) {
    action_->setShortcut(key);
  }

  void setShortcut(const QString &shortcut) {
    action_->setShortcut(shortcut);
  }

  void setStatusTip(const QString &tip) {
    action_->setStatusTip(tip);
  }

  void setIcon(uchar *data, uint len) {
    QPixmap pixmap;

    pixmap.loadFromData(data, len);

    QIcon icon(pixmap);

    action_->setIcon(icon);
  }

  void setIcon(const QIcon &icon) {
    action_->setIcon(icon);
  }

  void setXPMIcon(const char **xpmData) {
    action_->setIcon(QIcon(QPixmap(xpmData)));
  }

  bool isChecked() const {
    return action_->isChecked();
  }

  void setCheckable(bool checkable) {
    action_->setCheckable(checkable);
  }

  void setChecked(bool checked) {
    action_->setChecked(checked);
  }

  bool isEnabled() const {
    return action_->isEnabled();
  }

  void setEnabled(bool enabled) {
    action_->setEnabled(enabled);
  }

  bool connect(const char *signal, const QObject *recv, const char *method) {
    return QObject::connect(getAction(), signal, recv, method);
  }

  bool connect(const QObject *recv, const char *method) {
    if (strstr(method, "(bool)"))
      return QObject::connect(getAction(), SIGNAL(triggered(bool)), recv, method);
    else
      return QObject::connect(getAction(), SIGNAL(triggered()), recv, method);
  }

 private:
  CQMenu  *menu_ { nullptr };
  QAction *action_ { nullptr };
};

//------

inline void
CQMenu::
addMenuItem(CQMenuItem *menuItem)
{
  addAction(menuItem->getAction());

  menuItemMap_[menuItem->getName()] = menuItem;
}

#endif
##concat##CQMsgHandler.h
#ifndef CQMsgHandler_H
#define CQMsgHandler_H

namespace CQMsgHandler {

void install();

};

#endif
##concat##CQPenUtil.h
#ifndef CQPenUtil_H
#define CQPenUtil_H

#ifdef CQUTIL_PEN
#include <CPen.h>
#endif

#include <QPen>

namespace CQPenUtil {

#ifdef CQUTIL_PEN
QPen toQPen(const CPen &pen);
#endif

}

#endif
##concat##CQPixmapButton.h
#ifndef CQPixmapButton_H
#define CQPixmapButton_H

#include <QToolButton>

class CQPixmapButton : public QToolButton {
  Q_OBJECT

  Q_PROPERTY(int margin READ margin WRITE setMargin)

 public:
  CQPixmapButton(const QString &fileName);
  CQPixmapButton(uchar *data, uint len);
  CQPixmapButton(const QPixmap &pixmap);
  CQPixmapButton(const QIcon &icon);

  virtual ~CQPixmapButton() { }

  int margin() const { return margin_; }
  void setMargin(int i);

  QSize sizeHint() const override;
  QSize minimumSizeHint() const override;

 private:
  void init(const QPixmap &pixmap);
  void init(const QIcon &icon);

 private:
  QSize size_;
  int   margin_ { 8 };
};

#endif
##concat##CQPixmapCache.h
#ifndef CQPixmapCache_H
#define CQPixmapCache_H

#include <QString>
#include <QPixmap>
#include <QIcon>
#include <map>

#define CQPixmapCacheInst CQPixmapCache::instance()

class CQPixmapCache : public QObject {
  Q_OBJECT

 public:
  static CQPixmapCache *instance();

  static void release();

 public:
 ~CQPixmapCache();

  bool isDark() const { return dark_; }
  void setDark(bool b) { dark_ = b; }

  void clear();

  void addData(const QString &id, const uchar *data, int len);

  bool hasPixmap(const QString &id) const;

  const QPixmap &getPixmap(const QString &id);

  QIcon getLightDarkIcon(const QString &name);

  QIcon getIcon(const QString &lightId, const QString &darkId="");

  QIcon getPixmapIcon(const QString &id);

  QPixmap getSizedPixmap(const QString &id, const QSize &s);

 private:
  CQPixmapCache();

 private slots:
  void updateTheme();

 private:
  struct Data {
    const uchar *data   = 0;
    int          len    = 0;
    QPixmap     *pixmap = 0;

    Data(const uchar *data1=0, int len1=0) :
     data(data1), len(len1) {
    }

   ~Data() {
      delete pixmap;
    }
  };

  typedef std::map<QString, Data> IdData;

  IdData idData_;
  bool   dark_ { false };
};

#endif
##concat##CQPoint2DEdit.h
#ifndef CQPoint2DEdit_H
#define CQPoint2DEdit_H

#include <QLineEdit>
#include <QDoubleSpinBox>
#include <QHBoxLayout>
#include <CPoint2D.h>

class CQPoint2DEdit : public QFrame {
  Q_OBJECT

  Q_PROPERTY(bool spin     READ isSpin   WRITE setSpin    )
  Q_PROPERTY(int  decimals READ decimals WRITE setDecimals)

 public:
  CQPoint2DEdit(QWidget *parent, const CPoint2D &value=CPoint2D(0, 0), bool spin=false);
  CQPoint2DEdit(const CPoint2D &value=CPoint2D(0, 0), bool spin=false);

  CQPoint2DEdit(QWidget *parent, const QPointF &value, bool spin=false);
  CQPoint2DEdit(const QPointF &value, bool spin=false);

  virtual ~CQPoint2DEdit() { }

  bool isSpin() const { return spin_; }
  void setSpin(bool b);

  int decimals() const { return decimals_; }
  void setDecimals(int i);

  void setValue(const CPoint2D &point);
  void setValue(const QPointF &point);

  void setMinimum(const CPoint2D &point);
  void setMaximum(const CPoint2D &point);
  void setStep(const CPoint2D &point);

  const CPoint2D &getValue() const;
  QPointF getQValue() const;

 private:
  void init(const CPoint2D &value);

 private slots:
  void editingFinishedI();

 signals:
  void valueChanged();

 private:
  void updateRange();

  void pointToWidget();
  void widgetToPoint();

 private:
  CPoint2D          point_          { 0, 0 };
  bool              spin_           { false };
  CPoint2D          min_            { -1E50, -1E50 };
  CPoint2D          max_            { 1E50, 1E50 };
  CPoint2D          step_           { 1, 1 };
  int               decimals_       { 3 };
  QDoubleValidator *x_validator_    { nullptr };
  QDoubleValidator *y_validator_    { nullptr };
  QLineEdit        *x_edit_         { nullptr };
  QLineEdit        *y_edit_         { nullptr };
  QDoubleSpinBox   *x_spin_         { nullptr };
  QDoubleSpinBox   *y_spin_         { nullptr };
  QHBoxLayout      *layout_         { nullptr };
  mutable bool      disableSignals_ { false };
};

#endif
##concat##CQProgressLabel.h
#ifndef CQProgressLabel_H
#define CQProgressLabel_H

#include <QFrame>

class CQProgressLabel : public QFrame {
  Q_OBJECT

  Q_PROPERTY(int progress READ progress WRITE setProgress)

 public:
  CQProgressLabel(QWidget *parent=nullptr);

  int progress() const { return progress_; }
  void setProgress(int i) { progress_ = std::min(std::max(i, 0), 100); update(); }

  const QColor &progressColor() const { return progressColor_; }
  void setProgressColor(const QColor &c) { progressColor_ = c; }

  void paintEvent(QPaintEvent *) override;

  QSize sizeHint() const override;

 private:
  int    progress_      { 0 };
  QColor progressColor_ { 40, 180, 40 };
};

#endif
##concat##CQRadioButtons.h
#ifndef CQRadioButtons_H
#define CQRadioButtons_H

#include <vector>
#include <QWidget>

class QRadioButton;
class QLayout;

class CQRadioButtons : public QWidget {
  Q_OBJECT

 public:
  CQRadioButtons(QWidget *parent=0);

  virtual ~CQRadioButtons();

  void addButton(const QString &name);

  int getCurrentValue() const;

  QString getCurrentName () const;
  void setCurrentName(const QString &name);

 protected:
  void addButtons(const std::vector<QString> &names);

  virtual QLayout *createLayout(QWidget *parent);

  virtual void addWidget(QWidget *widget);

 protected slots:
  void valueChangedI(bool value);

 signals:
  void valueChanged(int id);
  void valueChanged(const QString &d);

 protected:
  typedef std::vector<QRadioButton *> Buttons;

  bool    hasLayout_ { false };
  Buttons buttons_;
};

//------

class CQHRadioButtons : public CQRadioButtons {
 public:
  CQHRadioButtons(QWidget *parent, const char *name, ...);
  CQHRadioButtons(QWidget *parent=0);

 protected:
  QLayout *createLayout(QWidget *parent);

  void addWidget(QWidget *widget);
};

//------

class CQVRadioButtons : public CQRadioButtons {
 public:
  CQVRadioButtons(QWidget *parent, const char *name, ...);
  CQVRadioButtons(QWidget *parent=0);

 protected:
  QLayout *createLayout(QWidget *parent);

  void addWidget(QWidget *widget);
};

//------

class CQToolbarRadioButtons : public CQRadioButtons {
 public:
  CQToolbarRadioButtons(QWidget *parent, const char *title, const char *name, ...);
  CQToolbarRadioButtons(QWidget *parent, const char *title);

 protected:
  QLayout *createLayout(QWidget *parent);

  void addWidget(QWidget *widget);

 protected:
  QString title_;
};

#endif
##concat##CQRealEdit.h
#ifndef CQREAL_EDIT_H
#define CQREAL_EDIT_H

#include <QLineEdit>
#include <QAction>

class QDoubleValidator;
class QContextMenuEvent;
class QMenu;

class CQRealEdit : public QLineEdit {
  Q_OBJECT

 public:
  CQRealEdit(QWidget *parent, double value=0.0);
  CQRealEdit(double value=0.0);

  virtual ~CQRealEdit() { }

  void setValue(double value);

  double getValue() const;

  void setRange(double lower, double upper, int decimals=0);

  void addMenuValue(double value);

 private:
  void init(const QString &name, double value);

  void contextMenuEvent(QContextMenuEvent *);

 private slots:
  void editingFinishedI();
  void menuItemActivated(QAction *);

 signals:
  void valueChanged(double);

 private:
  void valueToWidget();
  bool widgetToValue();

 private:
  double            value_     { 0.0 };
  QDoubleValidator *validator_ { nullptr };
  QMenu            *menu_      { nullptr };
};

//---

class CQRealEditAction : public QAction {
 public:
  CQRealEditAction(double value);

  double getValue() const { return value_; }

 private:
  double value_ { 0.0 };
};

#endif
##concat##CQRealSpin.h
#ifndef CQRealSpin_H
#define CQRealSpin_H

#include <QDoubleSpinBox>

/*!
 * \brief Extension of QDoubleSpinBox to allow sping box to increment the digit at the
 * current cursor position
 */
class CQRealSpin : public QDoubleSpinBox {
  Q_OBJECT

  Q_PROPERTY(bool   autoStep READ isAutoStep WRITE setAutoStep)
  Q_PROPERTY(double step     READ step)

 public:
  CQRealSpin(QWidget *parent, double value=0);
  CQRealSpin(double value=0);

  virtual ~CQRealSpin() { }

  //! get/set auto step
  bool isAutoStep() const { return autoStep_; }
  void setAutoStep(bool b) { autoStep_ = b; }

  //! get current step
  double step() const { return step_; }

  //! step by n
  void stepBy(int n);

  //! get/set cursor position
  int cursorPosition() const;
  void setCursorPosition(int pos);

 signals:
  //! emitted when step changed
  void stepChanged(double);

 private slots:
  //! update step from cursor position
  void updateStep();

 private:
  //! init widget with current value
  void init(double value);

  //! calc step for cursor position
  double posToStep(int pos) const;

  //! check if value is negative
  bool isNegative() const;

  //! find position of decimal point
  int dotPos() const;

 private:
  bool   autoStep_ { true }; //!< support increment using cursor position
  double step_     { 1 };    //!< current step increment
};

#endif
##concat##CQRectEdit.h
#ifndef CQRectEdit_H
#define CQRectEdit_H

#include <QLineEdit>
#include <QDoubleSpinBox>
#include <QHBoxLayout>

class CQRectEdit : public QFrame {
  Q_OBJECT

 public:
  CQRectEdit(QWidget *parent, const QRectF &value=QRectF(0, 0, 1, 1));
  CQRectEdit(const QRectF &value=QRectF(0, 0, 1, 1));

  virtual ~CQRectEdit() { }

  void setValue(const QRectF &rect);
  const QRectF &getValue() const;

 private:
  void init(const QRectF &value);

 private slots:
  void editingFinishedI();

 signals:
  void valueChanged();

 private:
  void updateRange();

  void rectToWidget();
  bool widgetToPoint();

 private:
  QRectF       rect_           { 0, 0, 1, 1 };
  QLineEdit*   edit_           { nullptr };
  QHBoxLayout* layout_         { nullptr };
  mutable bool disableSignals_ { false };
};

#endif
##concat##CQScrollArea.h
#ifndef CQScrollArea_H
#define CQScrollArea_H

#include <QFrame>

class QScrollBar;
class QPainter;

/*!
 * Area to contain a virtual scrollable widget.
 *
 * The actual widget is the same size as the scroll area
 * (unlike QScrollArea which uses a widget of any size).
 *
 * The widget needs to tell the scroll area the virtual widget size and the scroll bars
 * update the virtual widget offsets which are used in the widget's paint event to draw
 * the contents at the specified offset.
 *
 * This is more efficient for large widgets or widgets that can clip themselves.
 *
 * API:
 *   Use setXSize and setYSize to set virutal size
 *
 *   Use getXOffset and getYOffset when drawing into widget
 *
 *   Use setXSingleStep and setYSingleStep to set scroll step
 *
 *   Call handleWheelEvent in event override for QEvent::Wheel to scroll on wheel
 */
class CQScrollArea : public QFrame {
  Q_OBJECT

 public:
  CQScrollArea(QWidget *parent, QWidget *widget);
  CQScrollArea(QWidget *widget);

  virtual ~CQScrollArea() { }

  //! get/set child widget (can only be set once)
  QWidget *getWidget() const { return widget_; }
  void setWidget(QWidget *widget);

  //! show/hide horizontal/vertical scroll bar
  void showHBar(bool flag);
  void showVBar(bool flag);

  //! set corner widget
  void setCornerWidget(QWidget *w);

  //! get/set virtual widget size
  int getXSize() const { return x_size_; }
  void setXSize(int x_size);

  //! get/set virtual widget size
  int getYSize() const { return y_size_; }
  void setYSize(int y_size);

  //! get/set virtual widget x offset
  int getXOffset() const { return x_offset_; }
  void setXOffset(int x_offset);

  //! get/set virtual widget y offset
  void setYOffset(int y_offset);
  int getYOffset() const { return y_offset_; }

  //! set x/y scrollbar single step
  void setXSingleStep(int x);
  void setYSingleStep(int y);

  //! handle scroll directions
  void scrollUp   (bool page=false);
  void scrollDown (bool page=false);
  void scrollLeft (bool page=false);
  void scrollRight(bool page=false);

  //! ensure pixel position widget
  void ensureVisible(int x, int y, int xmargin=50, int ymargin=50);

  //! update scrollbars (called when virtual widget changes)
  void updateScrollbars();

  //! update contents
  virtual void updateContents() { }

  //! handle wheel event
  void handleWheelEvent(QWheelEvent *e);

 private slots:
  void hscrollSlot(int value);
  void vscrollSlot(int value);

 signals:
  void updateArea();

 private:
  void init();

 private:
  QWidget*    widget_   { nullptr };
  QScrollBar* hbar_     { nullptr };
  QScrollBar* vbar_     { nullptr };
  int         x_size_   { -1 };
  int         y_size_   { -1 };
  int         x_offset_ { 0 };
  int         y_offset_ { 0 };
};

#endif
##concat##CQSlider.h
#ifndef CQSlider_H
#define CQSlider_H

#include <QSlider>

class CQSlider : public QSlider {
  Q_OBJECT

  Q_PROPERTY(QString valueLabel READ valueLabel WRITE setValueLabel)

 public:
  CQSlider(QWidget *parent=nullptr);

  const QString &valueLabel() const { return valueLabel_; }
  void setValueLabel(const QString &label);

  QSize sizeHint() const override;

 private:
  void paintEvent(QPaintEvent *) override;

  int valueToPos(int v) const;

  int valueWidthToPos(int v, int width) const;

  void drawTick(QPainter *p, int val, int y, int s);

 private:
  QString     valueLabel_;
  QFont       valFont_;
  QFont       tickFont_;
  mutable int sliderHeight_ { 0 };
  mutable int dx_           { 0 };
  mutable int dy_           { 0 };
};

//---

class CQRealSlider : public QSlider {
  Q_OBJECT

  Q_PROPERTY(QString valueLabel READ valueLabel WRITE setValueLabel)
  Q_PROPERTY(double  minimum    READ minimum    WRITE setMinimum   )
  Q_PROPERTY(double  maximum    READ maximum    WRITE setMaximum   )
  Q_PROPERTY(double  singleStep READ singleStep WRITE setSingleStep)

 public:
  CQRealSlider(QWidget *parent=nullptr);

  const QString &valueLabel() const { return valueLabel_; }
  void setValueLabel(const QString &label);

  double minimum() const { return minimum_; }
  void setMinimum(double r);

  double maximum() const { return maximum_; }
  void setMaximum(double r);

  void setRange(double minimum, double maximum);

  double singleStep() const { return singleStep_; }
  void setSingleStep(double r);

  double value() const { return value_; }
  void setValue(double r);

  QSize sizeHint() const override;

 private:
  void paintEvent(QPaintEvent *) override;

  int valueToPos(double v) const;

  int valueWidthToPos(double v, int width) const;

  void drawTick(QPainter *p, double val, int y, int s);

 signals:
  void valueChanged(double);
  void rangeChanged(double, double);

 private slots:
  void valueChangedSlot(int);

 private:
  QString valueLabel_;
  double  minimum_    { 0.0 };
  double  maximum_    { 1.0 };
  double  singleStep_ { 0.01 };
  double  value_      { 0.0 };
  QFont   valFont_;
  QFont   tickFont_;

  mutable int sliderHeight_ { 0 };
  mutable int dx_           { 0 };
  mutable int dy_           { 0 };
};

#endif
##concat##CQStrParse.h
#ifndef CQStrParse_H
#define CQStrParse_H

#include <QString>
#include <sys/types.h>

class CQStrParse {
 public:
  explicit CQStrParse(const QString &str="");

  virtual ~CQStrParse() { }

  bool isAutoSkipSpace() const { return autoSkipSpace_; }
  void setAutoSkipSpace(bool autoSkipSpace=true) { autoSkipSpace_ = autoSkipSpace; }

  virtual void setString(const QString &str);

  virtual const QString &getString() const { return str_; }

  virtual void addString(const QString &str);

  virtual int getPos() const { return pos_; }

  virtual int getLen() const { return len_; }

  virtual void setPos(int pos);

  int lineNum() const { return lineNum_; }

  virtual QString getAt    () const;
  virtual QString getAt    (int pos) const;
  virtual QString getAt    (int pos, int len) const;
  virtual QString getBefore(int pos=0) const;
  virtual QString getAfter () const;

  virtual QChar getCharBefore(int offset = 1) const;
  virtual QChar getCharAt    () const;
  virtual QChar getCharAt    (int pos) const;
  virtual QChar getCharAfter (int offset = 1) const;

  virtual void skipSpace();
  virtual void skipNonSpace();

  virtual void backSkipSpace();

  virtual QChar getChar();

  virtual bool skipChar();
  virtual bool skipChar(QChar c);
  virtual bool skipChars(const QString &s);
  virtual bool skipChars(int n);
  virtual bool skipString();
  virtual void skipToEnd();

  virtual bool backSkipChar();

  virtual void autoSkipSpace() const;
  virtual void autoBackSkipSpace() const;

  virtual bool readNonSpace(QString &text);

  virtual bool skipBracedString();
  virtual bool readBracedString(QString &text, bool includeBraces=false);

  virtual bool  readChar(QChar *c);
  virtual QChar readChar();
  virtual bool  unreadChar();

  //virtual bool readUtf8Char(ulong *c);

  virtual bool unreadString(const QString &str);

  virtual bool readNumber(double &real, int &integer, bool &is_real);
  virtual bool readNumber(double &real, long &integer, bool &is_real);

  virtual bool readInteger(int *integer);
  virtual bool readInteger(long *integer);

  virtual bool readBaseInteger(int base, int *integer);
  virtual bool readBaseInteger(int base, long *integer);

  virtual bool readReal(double *real);

  virtual bool readString(QString &str, bool strip_quotes=false);

  virtual bool skipToChar(QChar c);
  virtual bool readToChar(QChar c, QString &text);

  virtual bool isIdentifier(int offset=0);
  virtual bool readIdentifier(QString &identifier);

  //virtual bool readRealFormat(QString &real_format);
  //virtual bool readIntegerFormat(QString &integer_format);
  //virtual bool readStringFormat(QString &string_format);

  virtual bool isSpace() const;
  virtual bool isNewline() const;

  virtual bool isAlpha() const;
  virtual bool isLower() const;
  virtual bool isUpper() const;
  virtual bool isAlnum() const;
  virtual bool isDigit() const;
  virtual bool isDigitAt(int offset) const;
  virtual bool isODigit() const;
  virtual bool isXDigit() const;

  virtual bool isCharBefore(QChar c, int offset = 1) const;
  virtual bool isChar(QChar c) const;
  virtual bool isCharAfter(QChar c, int offset = 1) const;

  virtual bool isNextChar(QChar c) const;

  virtual bool isString(const QString &str) const;
  virtual bool isOneOf(const QString &str) const;

  virtual bool isWord(const QString &str) const;
  virtual void skipWord(const QString &str);

  virtual bool eof() const;

  virtual bool neof(int n) const;

  virtual bool sof() const;

  virtual QString stateStr() const {
    return getBefore() + getCharAt() + "\b_" + getAfter();
  }

 private:
  bool skipSpaceI(const QString &str, int *pos);
  bool skipNonSpaceI(const QString &str, int *pos);

  bool backSkipSpaceI(const QString &str, int *pos);

  bool skipDoubleQuotedStringI(const QString &str, int *pos);
  bool skipSingleQuotedStringI(const QString &str, int *pos);

  bool toRealI(const QString &str, double *real);
  bool toIntegerI(const QString &str, int *integer);
  bool toIntegerI(const QString &str, long *integer);

  bool readIntegerI(const QString &str, int *pos, long *integer);
  bool readBaseIntegerI(const QString &str, int base, int *pos, long *integer);
  bool readRealI(const QString &str, int *pos, double *real);
  bool readNumberI(const QString &str, int *pos, double &real, long &integer, bool &is_real);

  bool skipIntegerI(const QString &str, int *pos);
  bool skipBaseIntegerI(const QString &str, int base, int *pos);

  bool isBaseCharI(const QChar &c, int base, int *value);

  bool toBaseIntegerI(const QString &str, int base, long *integer);

  bool readIdentifierI(const QString &str, int *pos, QString &identifier);

  bool isIdentifierI(const QString &str, int pos);

 private:
  QString str_;
  int     pos_ { 0 };
  int     len_ { 0 };
  bool    autoSkipSpace_ { false };
  int     lineNum_ { 1 };
};

#endif
##concat##CQStrUtil.h
#ifndef CQStrUtil_H
#define CQStrUtil_H

#include <QStringList>

namespace CQStrUtil {

double toReal(const QString &str, bool &ok);

long toInt(const QString &str, bool &ok);

long toInt(const char *c_str, bool &ok, const char **p);

}

//---

namespace CQStrUtil {

enum class MatchType {
  START
};

QStringList matchStrs(const QString &str, const QStringList &strs,
                      MatchType matchType=MatchType::START);

QString longestMatch(const QStringList &items, bool &exact);

}

#endif
##concat##CQStyle.h
#ifndef CQStyle_H
#define CQStyle_H

#include <CQStyleMgr.h>
#include <QProxyStyle>

class CQStyle : public QProxyStyle {
  Q_PROPERTY(Theme theme READ theme WRITE setTheme)

  Q_ENUMS(Theme)

 public:
  enum class Theme {
    LIGHT = int(CQStyleMgr::Theme::LIGHT),
    DARK  = int(CQStyleMgr::Theme::DARK)
  };

 public:
  CQStyle();

  //---

  const Theme &theme() const { return theme_; }
  void setTheme(const Theme &t);

  //---

  void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
                           QPainter *painter, const QWidget *widget = 0) const override;

  void drawControl(ControlElement element, const QStyleOption *option, QPainter *painter,
                   const QWidget *widget = 0) const override;

  void drawItemPixmap(QPainter *painter, const QRect &rect, int alignment,
                      const QPixmap &pixmap) const override;

  void drawItemText(QPainter *painter, const QRect &rect, int flags, const QPalette &pal,
                    bool enabled, const QString &text,
                    QPalette::ColorRole textRole = QPalette::NoRole) const override;

  void drawPrimitive(PrimitiveElement element, const QStyleOption *option, QPainter *painter,
                     const QWidget *widget = 0) const override;

  QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
                              const QStyleOption *opt) const override;

  SubControl hitTestComplexControl(ComplexControl control, const QStyleOptionComplex *option,
                                   const QPoint &pos, const QWidget *widget = 0) const override;

  QRect itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const override;
  QRect itemTextRect(const QFontMetrics &fm, const QRect &r, int flags, bool enabled,
                     const QString &text) const override;

  int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
                  const QWidget *widget = 0) const override;

#if 0
  void polish(QWidget *widget) override;
  void polish(QPalette &pal) override;
  void polish(QApplication *app) override;
#endif

  QSize sizeFromContents(ContentsType type, const QStyleOption *option, const QSize &size,
                         const QWidget *widget) const override;

  QPalette standardPalette() const override;

  QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
                         const QWidget *widget = 0) const override;

  int styleHint(StyleHint hint, const QStyleOption *option = 0, const QWidget *widget = 0,
                QStyleHintReturn *returnData = 0) const override;

  QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *option, SubControl sc,
                       const QWidget *widget) const override;
#if 0
  QRect subElementRect(SubElement element, const QStyleOption *option,
                       const QWidget *widget) const override;

  void unpolish(QWidget *widget) override;
  void unpolish(QApplication *app) override;
#endif

 private:
  void drawCheck(QPainter *p, const QRectF &r, const QBrush &b) const;

 private:
  Theme    theme_ { Theme::LIGHT };
  QPalette palette_;
};

#endif
##concat##CQStyleMgr.h
#ifndef CQStyleMgr_H
#define CQStyleMgr_H

#include <QObject>
#include <QColor>
#include <QFont>

#define CQStyleMgrInst CQStyleMgr::instance()

class CQStyle;

class CQStyleMgr : public QObject {
  Q_OBJECT

  Q_PROPERTY(Theme  theme          READ theme          WRITE setTheme         )
  Q_PROPERTY(QColor lightBaseColor READ lightBaseColor WRITE setLightBaseColor)
  Q_PROPERTY(QColor darkBaseColor  READ darkBaseColor  WRITE setDarkBaseColor )
  Q_PROPERTY(int    iconSize       READ iconSize       WRITE setIconSize      )
  Q_PROPERTY(int    smallIconSize  READ smallIconSize  WRITE setSmallIconSize )
  Q_PROPERTY(int    largeIconSize  READ largeIconSize  WRITE setLargeIconSize )
  Q_PROPERTY(QFont  font           READ font           WRITE setFont          )
  Q_PROPERTY(QFont  fixedFont      READ fixedFont      WRITE setFixedFont     )

  Q_ENUMS(Theme)

 public:
  enum class Theme {
    LIGHT,
    DARK
  };

 public:
  static CQStyleMgr *instance();

  CQStyle *createStyle();
  CQStyle *style() const { return style_; }

  //---

  const Theme &theme() const { return theme_; }
  void setTheme(const Theme &t);

  //---

  QColor calcBaseColor() const;

  //---

  const QColor &lightBaseColor() const { return lightBaseColor_; }
  void setLightBaseColor(const QColor &c) { lightBaseColor_ = c; emit colorsChanged(); }

  const QColor &darkBaseColor() const { return darkBaseColor_; }
  void setDarkBaseColor(const QColor &c) { darkBaseColor_ = c; emit colorsChanged(); }

  //---

  int iconSize() const { return iconSize_; }
  void setIconSize(int i);

  void setIconSizeFromFont();

  int smallIconSize() const { return smallIconSize_; }
  void setSmallIconSize(int i);

  int calcSmallIconSize() const;

  int largeIconSize() const { return largeIconSize_; }
  void setLargeIconSize(int i);

  int calcLargeIconSize() const;

  //---

  const QFont &font() const { return font_; }
  void setFont(const QFont &font);

  const QFont &fixedFont() const { return fixedFont_; }
  void setFixedFont(const QFont &font);

 protected:
  CQStyleMgr();

 signals:
  void themeChanged();
  void colorsChanged();

  void iconSizeChanged();

  void fontChanged();
  void fixedFontChanged();

 private:
  CQStyle* style_         { nullptr };
  QColor   lightBaseColor_;
  QColor   darkBaseColor_;
  Theme    theme_         { Theme::LIGHT };
  QFont    font_;
  QFont    fixedFont_;
  int      iconSize_      { 16 };
  int      largeIconSize_ { -1 };
  int      smallIconSize_ { -1 };
};

#endif
##concat##CQSwitch.h
#ifndef CQSwitch_H
#define CQSwitch_H

#include <QAbstractButton>

class CQSwitch : public QAbstractButton {
  Q_OBJECT

  Q_PROPERTY(QString onLabel     READ onLabel       WRITE setOnLabel    )
  Q_PROPERTY(QString offLabel    READ offLabel      WRITE setOffLabel   )
  Q_PROPERTY(int     margin      READ margin        WRITE setMargin     )
  Q_PROPERTY(bool    highlightOn READ isHighlightOn WRITE setHighlightOn)

 public:
  CQSwitch(QWidget *parent=nullptr);
  CQSwitch(QWidget *parent, const QString &onLabel, const QString &offLabel);
  CQSwitch(const QString &onLabel, const QString &offLabel, QWidget *parent=nullptr);

  const QString &onLabel() const { return onLabel_; }
  void setOnLabel(const QString &v) { onLabel_ = v; }

  const QString &offLabel() const { return offLabel_; }
  void setOffLabel(const QString &v) { offLabel_ = v; }

  int margin() const { return margin_; }
  void setMargin(int i) { margin_ = i; }

  bool isHighlightOn() const { return highlightOn_; }
  void setHighlightOn(bool b) { highlightOn_ = b; }

  QSize sizeHint() const override;

 public slots:
  void click();
  void toggle();

 signals:
  void released();

  //void toggled(bool b);

 private:
  void init();

  void mousePressEvent  (QMouseEvent *) override;
  void mouseReleaseEvent(QMouseEvent *) override;

  void paintEvent(QPaintEvent *) override;

 private:
  QString onLabel_     { "On"  };
  QString offLabel_    { "Off" };
  int     margin_      { 2 };
  bool    highlightOn_ { true };
};

#endif
##concat##CQTableView.h
#ifndef CQTableView_H
#define CQTableView_H

#include <QTableView>

class CQHeaderView;

class CQTableView : public QTableView {
  Q_OBJECT

 public:
  CQTableView(QWidget *parent=nullptr);

  virtual ~CQTableView();

  virtual void addMenuActions(QMenu *menu);

  void update();

 private slots:
  void customContextMenuSlot(const QPoint &pos);

  void showVertical();

 protected:
  CQHeaderView *header_ { nullptr };
};

#endif
##concat##CQTableWidget.h
#ifndef CQTableWidget_H
#define CQTableWidget_H

#include <QTableWidget>
#include <QPointer>

#include <cassert>
#include <vector>
#include <map>

class CQTableWidget;
class CQHeaderView;

class QLineEdit;
class QCheckBox;

class CQTableWidgetItem : public QObject, public QTableWidgetItem {
  Q_OBJECT

 public:
  // run-time type ID that is unique for each item
  // e.g. QTableWidgetItem::UserType + N
  static void setType(uint type) { type_ = type; }
  static uint getType() { return type_; }

  static bool isType(uint type) { return type == type_; }

  //---

  CQTableWidgetItem(CQTableWidget *table);

 ~CQTableWidgetItem() { }

  //---

  //! get/set model index
  const QModelIndex &modelIndex() const { return ind_; }
  void setModelIndex(const QModelIndex &i) { ind_ = i; }

  //! get/set is optional
  bool isOptional() const { return optional_; }
  void setOptional(bool b) { optional_ = b; }

  //---

  // clone new item
  virtual CQTableWidgetItem *clone() const = 0;

  // create edit widget for item
  virtual QWidget *createEditor(QWidget *parent) const = 0;

  // update edit widget from current item's data
  virtual void setEditorData() = 0;

  // update current item's data from edit widget
  virtual void getEditorData(QString &str) = 0;

  // get hint to item size
  virtual bool sizeHint(const QStyleOptionViewItem &, QSize &) const { return false; }

  // drawing override for static (not editted) item
  virtual bool paint(QPainter *, const QStyleOptionViewItem &) const { return false; }

  // get string value
  virtual QString getString() const = 0;

  virtual bool validate() const { return true; }

  // draw background in correct color for item state when editing
  void paintBackground(QPainter *painter, const QStyleOptionViewItem &option) const;

  // set correct pen color to draw text
  void setTextPen(QPainter *painter, const QStyleOptionViewItem &option) const;

  //---

 Q_SIGNALS:
  void valueChanged();

 protected:
  using CheckBoxP = QPointer<QCheckBox>;

  static uint type_;

  CQTableWidget*    table_    { nullptr };
  QModelIndex       ind_;
  bool              optional_ { false };
  bool              set_      { false };
  mutable CheckBoxP check_;
};

//---

class CQTableWidgetDelegate;

class CQTableWidget : public QTableWidget {
  Q_OBJECT

 public:
  CQTableWidget(QWidget* parent=nullptr);

  virtual ~CQTableWidget();

  CQTableWidgetDelegate *delegate() const { return delegate_; }

  void registerType(uint type, CQTableWidgetItem *item);

  void setColumnLabel(int col, const QString &label);
  void setRowLabel(int row, const QString &label);

  void setColumnLabels(const QStringList &labels);
  void setRowLabels(const QStringList &labels);

  template<typename T>
  T *createItem(int row, int column) {
    uint type = T::getType();

    return dynamic_cast<T *>(createItem(row, column, type));
  }

  template<typename T>
  T *getItem(int row, int column) {
    auto *i = item(row, column);

    auto *i1 = dynamic_cast<CQTableWidgetItem *>(i);
    assert(i1 != NULL);

    assert(i1->getType() == T::getType());

    return dynamic_cast<T *>(i1);
  }

  CQTableWidgetItem *createItem(int row, int column, uint type);

  void setItem(int row, int column, CQTableWidgetItem *item);
  void setItem(int row, int column, QTableWidgetItem *item);
  void setItem(int row, int column, const QString &str);
  void setItem(int row, int column, const QVariant &var);
  void setItem(int row, int column, QWidget *w);

  //---

  void fitAll();

  void fixTableColumnWidths();

  void emitValueChanged(int row, int col);

 protected:
  void showEvent(QShowEvent *) override;

  void fixTableColumnWidths(QTableWidget *table, int max_len, bool init);

 protected Q_SLOTS:
  void itemClickedSlot(const QModelIndex &index);

 Q_SIGNALS:
  void valueChanged(int row, int col);

  void boolClicked(int row, int col, bool value);

 protected:
  using TypeList = std::map<uint, CQTableWidgetItem*>;

  CQHeaderView*          header_ { nullptr };
  TypeList               types_;
  CQTableWidgetDelegate* delegate_ { nullptr };
};

//---

class CQTableWidgetBoolItem : public CQTableWidgetItem {
  Q_OBJECT

 public:
  enum { TYPE = QTableWidgetItem::UserType + 1 };

  CQTableWidgetBoolItem(CQTableWidget *table, bool b) :
   CQTableWidgetItem(table), b_(b) {
  }

  CQTableWidgetBoolItem *clone() const override { return new CQTableWidgetBoolItem(table_, b_); }

  QString getString() const override { return (b_ ? "true" : "false"); }

  QWidget *createEditor(QWidget *parent) const override;

  void setEditorData() override;
  void getEditorData(QString &str) override;

  bool sizeHint(const QStyleOptionViewItem &option, QSize &size) const override {
    size = QSize(128, option.rect.height());

    return true;
  }

  bool paint(QPainter *painter, const QStyleOptionViewItem &option) const override;

  void click() { b_ = ! b_; }

  bool value() const { return b_; }
  void setValue(bool b) { b_ = b; }

 private:
  static uint type_;

  bool b_ { false };
};

//---

class CQTableWidgetStringItem : public CQTableWidgetItem {
  Q_OBJECT

 public:
  enum { TYPE = QTableWidgetItem::UserType + 2 };

  CQTableWidgetStringItem(CQTableWidget *table, const QString &s) :
   CQTableWidgetItem(table), s_(s) {
  }

  CQTableWidgetStringItem *clone() const override {
    return new CQTableWidgetStringItem(table_, s_); }

  const QString &value() const { return s_; }

  QString getString() const override { return s_; }

  QWidget *createEditor(QWidget *parent) const override;

  void setEditorData() override;
  void getEditorData(QString &str) override;

  bool sizeHint(const QStyleOptionViewItem &option, QSize &size) const override {
    size = QSize(128, option.rect.height());

    return true;
  }

  bool paint(QPainter *painter, const QStyleOptionViewItem &option) const override;

 private:
  using LineEditP = QPointer<QLineEdit>;

  static uint type_;

  mutable LineEditP edit_;
  QString           s_;
};

//---

class CQColorChooser;

class CQTableWidgetColorItem : public CQTableWidgetItem {
  Q_OBJECT

 public:
  enum { TYPE = QTableWidgetItem::UserType + 3 };

  CQTableWidgetColorItem(CQTableWidget *table) :
   CQTableWidgetItem(table) {
  }

  CQTableWidgetColorItem(CQTableWidget *table, const QColor &c) :
   CQTableWidgetItem(table) {
    setValue(c);
  }

  CQTableWidgetColorItem *clone() const override {
    auto *item = new CQTableWidgetColorItem(table_);
    if (set_) item->setValue(c_);
    return item;
  }

  //! get/set value
  bool hasValue() const { return set_; }
  const QColor &value() const { assert(set_); return c_; }
  void setValue(const QColor &c) { set_ = true; c_ = c; }

  QString getString() const override { return (set_ ? value().name() : ""); }

  QWidget *createEditor(QWidget *parent) const override;

  void setEditorData() override;
  void getEditorData(QString &str) override;

  bool sizeHint(const QStyleOptionViewItem &option, QSize &size) const override {
    size = QSize(128, option.rect.height());

    return true;
  }

  bool paint(QPainter *painter, const QStyleOptionViewItem &option) const override;

 private:
  using ColorChooserP = QPointer<CQColorChooser>;

  static uint type_;

  mutable ColorChooserP edit_;
  QColor                c_;
};

//---

class CQFontChooser;

class CQTableWidgetFontItem : public CQTableWidgetItem {
  Q_OBJECT

 public:
  enum { TYPE = QTableWidgetItem::UserType + 4 };

  CQTableWidgetFontItem(CQTableWidget *table) :
   CQTableWidgetItem(table) {
  }

  CQTableWidgetFontItem(CQTableWidget *table, const QFont &font) :
   CQTableWidgetItem(table) {
    setValue(font);
  }

  CQTableWidgetFontItem *clone() const override {
    auto *item = new CQTableWidgetFontItem(table_);
    if (set_) item->setValue(font_);
    return item;
  }

  //! get/set value
  bool hasValue() const { return set_; }
  const QFont &value() const { assert(set_); return font_; }
  void setValue(const QFont &font) { set_ = true; font_ = font; }

  QString getString() const override { return font_.toString(); }

  QWidget *createEditor(QWidget *parent) const override;

  void setEditorData() override;
  void getEditorData(QString &str) override;

  bool sizeHint(const QStyleOptionViewItem &option, QSize &size) const override {
    size = QSize(128, option.rect.height());

    return true;
  }

  bool paint(QPainter *painter, const QStyleOptionViewItem &option) const override;

 private:
  using FontChooserP = QPointer<CQFontChooser>;

  static uint type_;

  mutable FontChooserP edit_;
  QFont                font_;
};

//---

class CQAlignEdit;

class CQTableWidgetAlignItem : public CQTableWidgetItem {
  Q_OBJECT

 public:
  enum { TYPE = QTableWidgetItem::UserType + 5 };

  CQTableWidgetAlignItem(CQTableWidget *table) :
   CQTableWidgetItem(table) {
  }

  CQTableWidgetAlignItem(CQTableWidget *table, const Qt::Alignment &align) :
   CQTableWidgetItem(table) {
    setValue(align);
  }

  CQTableWidgetAlignItem *clone() const override {
    auto *item = new CQTableWidgetAlignItem(table_);
    if (set_) item->setValue(align_);
    return item;
  }

  //! get/set value
  bool hasValue() const { return set_; }
  const Qt::Alignment &value() const { assert(set_); return align_; }
  void setValue(const Qt::Alignment &align) { set_ = true; align_ = align; }

  QString getString() const override;

  QWidget *createEditor(QWidget *parent) const override;

  void setEditorData() override;
  void getEditorData(QString &str) override;

  bool sizeHint(const QStyleOptionViewItem &option, QSize &size) const override {
    size = QSize(128, option.rect.height());

    return true;
  }

  bool paint(QPainter *painter, const QStyleOptionViewItem &option) const override;

 private:
  using AlignChooserP = QPointer<CQAlignEdit>;

  static uint type_;

  mutable AlignChooserP edit_;
  Qt::Alignment         align_ { Qt::AlignCenter };
};

#endif
##concat##CQTabSplit.h
#ifndef CQTabSplit_H
#define CQTabSplit_H

#include <QFrame>
#include <QSplitter>
#include <QTabWidget>
#include <QTabBar>
#include <QPointer>

class CQTabSplitSplitterTool;
class CQTabSplitTabBar;

class CQGroupBox;
class QVBoxLayout;

/*!
 * Widget which can switch between tabs and splitters
 *
 * TODO: auto switch depending on min size hint
 */
class CQTabSplit : public QFrame {
  Q_OBJECT

  Q_PROPERTY(Qt::Orientation orientation  READ orientation    WRITE setOrientation )
  Q_PROPERTY(State           state        READ state          WRITE setState       )
  Q_PROPERTY(bool            grouped      READ isGrouped      WRITE setGrouped     )
  Q_PROPERTY(bool            tabsClosable READ isTabsClosable WRITE setTabsClosable)
  Q_PROPERTY(bool            autoFit      READ isAutoFit      WRITE setAutoFit     )
  Q_PROPERTY(int             currentIndex READ currentIndex   WRITE setCurrentIndex)

  Q_ENUMS(State)

 public:
  enum class State {
    HSPLIT,
    VSPLIT,
    TAB,
    AUTO
  };

  using Sizes = QList<int>;

 public:
  explicit CQTabSplit(Qt::Orientation orient, QWidget *parent=nullptr);
  explicit CQTabSplit(QWidget *parent=nullptr);

  //---

  //! get/set orientation
  Qt::Orientation orientation() const { return orient_; }
  void setOrientation(Qt::Orientation orient);

  //! get/set state
  State state() const { return state_; }
  void setState(State state);

  //! get/set grouped
  bool isGrouped() const { return grouped_; }
  void setGrouped(bool b);

  //! get/set grouped (per widget)
  bool isGrouped(QWidget *w) const;
  void setGrouped(QWidget *w, bool b);

  //! get/set tabs closable
  bool isTabsClosable() const { return tabsClosable_; }
  void setTabsClosable(bool b);

  //! get/set auto fit
  bool isAutoFit() const { return autoFit_; }
  void setAutoFit(bool b) { autoFit_ = b; }

  //---

  int currentIndex() const { return currentIndex_; }
  void setCurrentIndex(int i);

  //---

  //! get indexed widget
  QWidget *widget(int i) const;

  //! add new widget
  void addWidget(QWidget *w, const QString &name);

  //! remove widget
  void removeWidget(QWidget *w, bool deleteWidget=true);
  void removeAllWidgets();

  //! has widget
  bool hasWidget(QWidget *w) const;

  //! set widget name
  void setWidgetName(QWidget *w, const QString &name);

  //! number of widgets
  int count() const;

  //! set splitter sizes
  void setSizes(const Sizes &sizes);

  //---

  CQTabSplitSplitterTool *getSplitterTool();

  //---

  //! return size hint
  QSize sizeHint() const override;

 signals:
  //! emitted when close of tab/splitter requested (if closable)
  void widgetCloseRequested(int i);

 public slots:
  void currentIndexSlot(int);

  //! close specified tab (if closable)
  void tabCloseSlot(int i);

 private:
  //! init widget
  void init();

 private:
  using WidgetP = QPointer<QWidget>;

  struct WidgetData {
    WidgetP      w;                  //!< widget
    QString      name;               //!< widget name (frou group)
    CQGroupBox*  group  { nullptr }; //!< group box (if grouped)
    QVBoxLayout* layout { nullptr }; //!< layout

    WidgetData() { }

    WidgetData(QWidget *w, const QString &name) :
     w(w), name(name) {
    }
  };

  using Widgets = std::vector<WidgetData>;

  Qt::Orientation orient_       { Qt::Horizontal }; //!< current orientation
  State           state_        { State::HSPLIT };  //!< current state
  bool            grouped_      { false };          //!< is grouped (use group boxes)
  bool            tabsClosable_ { false };          //!< are tabs closable
  bool            autoFit_      { false };          //!< is auto fit
  int             currentIndex_ { -1 };             //!< current index
  Widgets         widgets_;                         //!< widgets
  Sizes           hsizes_;                          //!< splitter sizes (horizontal)
  Sizes           vsizes_;                          //!< splitter sizes (vertical)
  QTabWidget*     tabWidget_    { nullptr };        //!< tab widget (if tabbed)
  QSplitter*      splitter_     { nullptr };        //!< splitter widget (if split)

  CQTabSplitSplitterTool *splitterTool_ { nullptr };
};

//---

/*!
 * \brief custom tab widget for CQTabSplit
 */
class CQTabSplitTabWidget : public QTabWidget {
  Q_OBJECT

 public:
  CQTabSplitTabWidget(CQTabSplit *split);

  //! get parent tab split
  CQTabSplit *split() const { return split_; }

  //! handle context menu event
  void contextMenuEvent(QContextMenuEvent *e) override;

  bool event(QEvent *event) override;

 private:
  void showTool(const QPoint &pos);

 private slots:
  //! set to horizontal split mode
  void hsplitSlot();

  //! set to vertical split mode
  void vsplitSlot();

  //! set current tab from context menu
  void tabSlot();

 private:
  CQTabSplit*       split_  { nullptr }; //!< parent tab split
  CQTabSplitTabBar* tabBar_ { nullptr }; //!< tab bar
};

//---

/*!
 * \brief custom tab tab for CQTabSplit
 */
class CQTabSplitTabBar : public QTabBar {
  Q_OBJECT

 public:
  CQTabSplitTabBar(CQTabSplitTabWidget *tabWidget);

 private:
  CQTabSplitTabWidget* tabWidget_ { nullptr };
};

#endif
##concat##CQTabSplitSplitter.h
#ifndef CQTabSplitSplitter_H
#define CQTabSplitSplitter_H

#include <QSplitter>

class CQTabSplit;
class CQTabSplitSplitterHandle;

/*!
 * \brief custom splitter widget for CQTabSplot
 */
class CQTabSplitSplitter : public QSplitter {
  Q_OBJECT

 public:
  using Sizes = QList<int>;

 public:
  CQTabSplitSplitter(CQTabSplit *split);

  //! get parent tab split
  CQTabSplit *split() const { return split_; }

  //! create custom handle
  QSplitterHandle *createHandle() override;

  //! get index for handle
  int handleIndex(CQTabSplitSplitterHandle *handle) const;

  //! fit specified split widget to size hint
  void autoFit(int ind);

  void setTabbed();

  void toggleSplit();

  //! fit all split widgets to size hint
  void fitAll();

  //! ensure sizes obey minimum size hint
  void fixSizes();

  //! handle resize
  void resizeEvent(QResizeEvent *) override;

  //! show/hide tool
  void showTool(const QPoint &pos);

 private:
  CQTabSplit *split_     { nullptr }; //!< parent tab split
  Sizes       lastSizes_;             //!< last splitter sizes
};

#endif
##concat##CQTabSplitSplitterHandle.h
#ifndef CQTabSplitSplitterHandle_H
#define CQTabSplitSplitterHandle_H

#include <QSplitter>

class CQTabSplitSplitter;

/*!
 * \brief custom splitter handler for CQTabSplitSplitter
 */
class CQTabSplitSplitterHandle : public QSplitterHandle {
  Q_OBJECT

  Q_PROPERTY(int barSize READ barSize WRITE setBarSize)

 public:
  CQTabSplitSplitterHandle(Qt::Orientation orient, CQTabSplitSplitter *splitter);

  CQTabSplitSplitter *splitter() const { return splitter_; }

  //! get/set bar size
  int barSize() const { return barSize_; }
  void setBarSize(int i) { barSize_ = i; }

  //! handle context menu event
  void contextMenuEvent(QContextMenuEvent *e) override;

  //! handle double click menu event (auto fit)
  void mouseDoubleClickEvent(QMouseEvent *) override;

  //! paint handle
  void paintEvent(QPaintEvent *) override;

  //! handle generic event (for hover)
  bool event(QEvent *event) override;

  //! return size hint
  QSize sizeHint() const override;

 private slots:
  void tabSlot();
  void splitSlot();
  void fitAllSlot();

 private:
  CQTabSplitSplitter *splitter_ { nullptr }; //!< parent splitter
  int                 barSize_  { 8 };       //!< bar size
  bool                hover_    { false };   //!< is hover
};

#endif
##concat##CQTabSplitSplitterTool.h
#ifndef CQTabSplitSplitterTool_H
#define CQTabSplitSplitterTool_H

#include <QFrame>

class CQTabSplit;
class CQTabSplitSplitter;
class CQIconButton;
class QTimer;

class CQTabSplitSplitterTool : public QFrame {
  Q_OBJECT

 public:
  CQTabSplitSplitterTool(CQTabSplit *split);

  const CQTabSplitSplitter *splitter() const { return splitter_; }
  void setSplitter(CQTabSplitSplitter *p) { splitter_ = p; }

  bool event(QEvent *event) override;

 private:
  void startHideTimer();
  void resetHideTimer();

 public slots:
  void showSlot();
  void hideSlot();

 private slots:
  void hsplitSlot();
  void vsplitSlot();
  void tabbedSlot();

 private:
  CQTabSplit*         split_    { nullptr }; //!< parent tab split
  CQTabSplitSplitter* splitter_ { nullptr }; //!< parent tab splitter
  CQIconButton*       hbutton_  { nullptr }; //!< horizontal split button
  CQIconButton*       vbutton_  { nullptr }; //!< vertical split button
  CQIconButton*       tbutton_  { nullptr }; //!< tabbed button
  QTimer*             timer_    { nullptr }; //!< hide timer
};

#endif
##concat##CQTabWidget.h
#ifndef CQTAB_WIDGET_H
#define CQTAB_WIDGET_H

#define CQTAB_WIDGET_MOVABLE 1

#include <QTabWidget>
#include <QTabBar>

class CQFloatEdit;
class CQTabWidgetTabBar;

class QMenu;

class CQTabWidget : public QTabWidget {
  Q_OBJECT

  Q_PROPERTY(bool showMoveButtons READ getShowMoveButtons WRITE setShowMoveButtons)

 public:
  CQTabWidget(QWidget *parent=nullptr);
 ~CQTabWidget();

  void addCreateButton();

  bool getShowMoveButtons() const { return moveButtons_; }

  void setShowMoveButtons(bool show);

  void contextMenuEvent(QContextMenuEvent *e) override;

  QMenu *createTabMenu() const;

 public slots:
  void moveTabLeft ();
  void moveTabRight();

  void moveTab(int fromIndex, int toIndex);

  void tabSlot();

 signals:
  void tabChanged(int ind);

  void createTab();

  void swapTabs(int ind1, int ind2);

 private:
  CQTabWidgetTabBar* tabBar_        { nullptr };
  bool               moveButtons_   { false };
  QWidget*           moveTabWidget_ { nullptr };
};

#endif
##concat##CQTabWidgetTabBar.h
#ifndef CQTabWidgetTabBar_H
#define CQTabWidgetTabBar_H

#define CQTAB_WIDGET_MOVABLE 1

#include <QTabBar>

class CQTabWidget;
class CQFloatEdit;

class CQTabWidgetTabBar : public QTabBar {
  Q_OBJECT

 public:
  CQTabWidgetTabBar(CQTabWidget *tabWidget);

  void stopEdit();

 protected:
  void mouseDoubleClickEvent(QMouseEvent *event) override;

#ifndef CQTAB_WIDGET_MOVABLE
  void mousePressEvent(QMouseEvent *event) override;
  void mouseMoveEvent (QMouseEvent *event) override;

  void dragEnterEvent(QDragEnterEvent *event) override;
  void dropEvent     (QDropEvent *event) override;
#endif

  void paintEvent(QPaintEvent *event) override;

  void contextMenuEvent(QContextMenuEvent *e) override;

 signals:
  void tabChanged(int ind);

  void tabMoveRequested(int fromIndex, int toIndex);

 private slots:
  void tabEditFinished(const QString &text);

 private:
  CQTabWidget* tabWidget_ { nullptr };
  CQFloatEdit *edit_      { nullptr };
  int          ind_       { -1 };
  QPoint       pressPos_;
};

#endif
##concat##CQToolBar.h
#ifndef CQTOOLBAR_H
#define CQTOOLBAR_H

#include <COptVal.h>

#include <QString>
#include <QSize>

class CQMenuItem;
class QMainWindow;
class QToolBar;
class QWidget;
class QAction;

#define CQToolBarMgrInst CQToolBarMgr::instance()

class CQToolBarMgr {
 public:
  static CQToolBarMgr *instance();

  static void release();

  const COptInt &iconSize() const { return iconSize_; }
  void setIconSize(int i) { iconSize_ = i; }

 private:
  CQToolBarMgr();

 private:
  COptInt iconSize_;
};

//---

class CQToolBar {
 public:
  CQToolBar(QMainWindow *main_window, const QString &name,
            Qt::ToolBarArea area=Qt::TopToolBarArea);

  QMainWindow *getMainWindow() const { return main_window_; }

  QToolBar *getToolBar() const { return toolbar_; }

  void setIconSize(const QSize &iconSize);

  QAction *addItem(CQMenuItem *item);
  QAction *addItem(QAction *action);

  QAction *addWidget(QWidget *widget);
  QAction *addWidget(QWidget *widget, bool checked);

  QAction *addSeparator();

  void setAllowedAreas(Qt::ToolBarAreas areas);

  void setVisible(bool visible);

 private:
  QMainWindow *main_window_ { nullptr };
  QToolBar    *toolbar_ { nullptr };
};

#endif
##concat##CQToolTip.h
#ifndef CQToolTip_H
#define CQToolTip_H

#include <QWidget>
#include <QPointer>
#include <QMap>

class QVBoxLayout;

// tooltip interface
class CQToolTipIFace {
 public:
  CQToolTipIFace() { }

  virtual ~CQToolTipIFace() { }

  // can display tip at point
  virtual bool canTip(const QPoint &) const { return true; }

  // get tip widget for point (return widget to show)
  virtual QWidget *showWidget(const QPoint &pos) = 0;

  // hide tip widget
  virtual void hideWidget() { }

  // update tip widget for new point (return false if can't display at new point)
  virtual bool updateWidget(const QPoint &) { return true; }

  // update tip on mouse move (with new point)
  virtual bool trackMouse() const { return false; }

  // seconds before hide (-1 means default)
  virtual double hideSecs() const { return -1; }

  // tip widget margin (-1 means default)
  virtual int margin() const { return -1; }

  // tip widget opacity (-1 means default)
  virtual double opacity() const { return -1; }

  // does tip allow transparency
  virtual bool isTransparent() const { return false; }

  // alignment of tip widget
  virtual Qt::Alignment alignment() const { return Qt::AlignLeft | Qt::AlignTop; }

  // allow tip outside parent
  virtual bool outside() const { return false; }

  // grab key press events
  virtual bool grabKey() const { return false; }

  // does key press hide tip (return false for allowed keys)
  virtual bool isHideKey(int, Qt::KeyboardModifiers) const { return true; }

  // handle allowed key press in tip
  virtual bool keyPress(int, Qt::KeyboardModifiers) { return true; }

  // widget size hint
  virtual QSize sizeHint() const { return QSize(); }
};

//---

// interface for standard widget
class CQToolTipWidgetIFace : public CQToolTipIFace {
 public:
  CQToolTipWidgetIFace(QWidget *w) :
    w_(w) {
  }

  virtual QWidget *showWidget(const QPoint &) { return w_; }

 private:
  using QWidgetP = QPointer<QWidget>;

  QWidgetP w_;
};

//---

#define CQToolTipInst CQToolTip::instance()

// tooltip singleton
class CQToolTip : public QWidget {
  Q_OBJECT

 public:
  // get singleton
  static CQToolTipIFace *getToolTip(QWidget *w);

  // set tooltip widget for parent widget
  static void setToolTip(QWidget *parent, QWidget *tooltip);
  // set tooltip interface for parent widget
  static void setToolTip(QWidget *parent, CQToolTipIFace *tooltip);

  // unset tooltip for parent widget
  static void unsetToolTip(QWidget *parent);

  // free singleton
  static void release();

 protected:
  // get instance
  static CQToolTip *instance();

  // protected constructor/destructor
  CQToolTip();
 ~CQToolTip();

  // show tooltip for interface at specified position
  bool show(const QPoint &pos, CQToolTipIFace *tooltip, QWidget *parent);

  // show widget tip at position
  bool showTip(QWidget *w, const QPoint &gpos);

 private:
  // show tip at position
  void showAtPos(const QPoint &pos);

  // handle enter event
  void enterEvent(QEvent *e) override;

  // handle paint event
  void paintEvent(QPaintEvent *) override;

  // handle generic event
  bool eventFilter(QObject *o, QEvent *e) override;

  // handle timer (hide) event
  void timerEvent(QTimerEvent *event) override;

  // hide after timeout
  void hideLater();

  // start/restart auto hide timer
  void startHideTimer();

  // stop hide timer
  void stopTimer();

  // update widget tip at position
  bool updateTip(QWidget *w, const QPoint &gpos);

  // update tip size
  void updateSize();

  // update tip opacity
  void updateOpacity(CQToolTipIFace *tooltip);

  // size hint
  QSize sizeHint() const override;

  // calc widget margin
  int calcMargin() const;

  // calc widget size
  QSize calcSize() const;

  // get desktop rect
  QRect desktopRect(const QPoint &pos) const;

 private slots:
  // handle hide timer signal
  void hideSlot();

 private:
  using QWidgetP  = QPointer<QWidget>;
  using WidgetMap = QMap<QWidgetP, CQToolTipIFace *>;

  static CQToolTip *s_instance;

  WidgetMap tooltips_;          //!< widget tooltips
  QWidgetP  tooltip_;           //!< current tooltip widget
  QWidgetP  parent_;            //!< current parent widget
  double    hideSecs_  { 3.0 }; //!< default hide timeout
  int       hideTimer_ { 0 };   //!< hide timer
  int       margin_    { 1 };   //!< default margin
  double    opacity_   { 0.8 }; //!< default opacity
  QPoint    showPos_;           //!< default position
};

#endif
##concat##CQTreeView.h
#ifndef CQTreeView_H
#define CQTreeView_H

#include <QTreeView>

class CQHeaderView;

class CQTreeView : public QTreeView {
  Q_OBJECT

 public:
  CQTreeView(QWidget *parent=nullptr);

  virtual ~CQTreeView();

  virtual void addMenuActions(QMenu *menu);

 private slots:
  void customContextMenuSlot(const QPoint &pos);

  void expandAll  (const QModelIndex &ind=QModelIndex());
  void collapseAll(const QModelIndex &ind=QModelIndex());

  void setRootSlot();

 private:
  CQHeaderView *header_ { nullptr };
  QModelIndex   menuIndex_;
};

#endif
##concat##CQTrie.h
#ifndef CQTrie_H
#define CQTrie_H

#include <QString>
#include <map>
#include <set>
#include <string>
#include <vector>
#include <iostream>

class CQTriePatterns;

/*!
 * \brief Trie Node
 * \ingroup 
 */
class CQTrieNode {
 public:
  using CharNodeMap = std::map<QChar, CQTrieNode *>;
  using String      = QString;

 public:
  CQTrieNode(CQTrieNode *parent=nullptr, QChar c='\0');

 ~CQTrieNode();

  CQTrieNode *parent() const { return parent_; }

  QChar c() const { return c_; }

  const CharNodeMap &children() const { return nodes_; }

  int numChildren() const { return nodes_.size(); }

  int count() const { return count_; }

  void incCount() { ++count_; }

  CQTrieNode *addChar(QChar c);

  String str() const;

  void patterns(int depth, CQTriePatterns &patterns) const;

  void subPatterns(const String &prefix, int depth, CQTriePatterns &patterns) const;

  int patternIndex(const String &str, const CQTriePatterns &patterns) const;

  int subPatternIndex(const String &str, int i, const CQTriePatterns &patterns) const;

#if 0
  String pattern() const;

  String parentPattern() const;

  String childPattern() const;

  String nodesPattern() const;

  void nodeChars(CharSet &charSet) const;
#endif

  int numWords() const;

  String escapeChar(QChar c) const;

 private:
  CQTrieNode* parent_ { nullptr };
  QChar             c_      { '\0' };
  CharNodeMap       nodes_;
  int               count_  { 0 };
};

//------

/*!
 * \brief Trie
 * \ingroup 
 */
class CQTrie {
 public:
  using CharSet = std::set<QChar>;
  using String  = QString;
  using Strings = std::vector<String>;

 public:
  CQTrie();

 ~CQTrie();

  void clear();

  void addWord(const String &str);

 private:
  template<class VISITOR>
  void visit(VISITOR &v, CQTrieNode *node, const String &str) {
    for (const auto &n : node->children()) {
      if (n.first.isNull())
        v.visit(str, n.second->count());
      else
        visit(v, n.second, str + n.first);
    }
  }

 public:
  CQTrieNode *root() const;

  int numWords() const;

 public:
  template<class VISITOR>
  void visit(VISITOR &v) {
    CQTrieNode *node = root();

    String str;

    visit(v, node, str);
  }

  void dump(std::ostream &os=std::cerr);

 private:
  struct MatchData {
    MatchData(const String &match) :
     str(match), len(match.size()) {
    }

    String str;
    uint   pos { 0 };
    uint   len;
  };

 public:
  void complete(const String &match, Strings &strs);

  void patterns(int depth, CQTriePatterns &patterns) const;

  int patternIndex(const String &str, const CQTriePatterns &patterns) const;

  String indexPattern(int i, const CQTriePatterns &patterns) const;

 private:
  void complete(CQTrieNode *node, const String &str, Strings &strs, MatchData &matchData);

  CQTrieNode *addNode(CQTrieNode *parent, QChar c);

 private:
  CQTrieNode* root_ { nullptr };
};

//------

/*!
 * Class used to return matching patterns in Trie
 */
class CQTriePatterns {
 public:
  using String     = QString;
  using Strings    = std::vector<String>;
  using NodeIndMap = std::map<const CQTrieNode *, int>;

 public:
  CQTriePatterns();

  int depth() const { return depth_; }
  void setDepth(int i) { depth_ = i; }

  void clear();

  int numPatterns() const;

  void addPattern(const CQTrieNode *node, const String &pattern);

  void addPatterns(const CQTriePatterns &patterns);

  int nodeInd(const CQTrieNode *node) const;

  String pattern(int i) const;

#if 0
  void print(std::ostream &os) const;
#endif

 private:
  int        depth_ { -1 };
  NodeIndMap nodeIndMap_;
  Strings    patterns_;
};

#endif
##concat##CQUtil.h
#ifndef CQUTIL_H
#define CQUTIL_H

#define CQUTIL_EVENT     1
#define CQUTIL_LINE_DASH 1
#define CQUTIL_ANGLE     1
#define CQUTIL_GRADIENT  1

#include <Qt>
#include <QColor>
#include <QEvent>
#include <QVariant>
#include <QTableWidget>
#include <QButtonGroup>
#include <QMenu>
#include <QBoxLayout>
#include <QAction>
#include <QPen>

#ifdef CQUTIL_EVENT
#include <CEvent.h>
#endif

#include <CRGBA.h>

#ifdef CQUTIL_LINE_DASH
#include <CLineDash.h>
#endif

#ifdef CQUTIL_ANGLE
#include <CAngle.h>
#endif

#include <CFontStyle.h>
#include <CLineCapType.h>
#include <CLineJoinType.h>
#include <CIBBox2D.h>

#include <CPoint2D.h>
#include <CBBox2D.h>
#include <CMatrix2D.h>
#include <CAlignType.h>

#include <map>

//---

#include <CQUtilMeta.h>

#ifdef CQUTIL_LINE_DASH
CQUTIL_DCL_META_TYPE(CLineDash)
#endif

#ifdef CQUTIL_ANGLE
CQUTIL_DCL_META_TYPE(CAngle)
#endif

//---

class QMouseEvent;
class QKeyEvent;
class QAbstractButton;
class QDockWidget;
class QLabel;

struct QMetaObject;

#ifdef CQUTIL_GRADIENT
class CLinearGradient;
class CRadialGradient;
#endif

namespace CQUtil {
  class PropInfo {
   public:
    PropInfo() { }

    void init(const QMetaProperty &mp);

    QString        name    () const { return name_; }
    QVariant::Type type    () const { return type_; }
    QString        typeName() const { return typeName_; }

    bool isWritable() const { return isWritable_ ; }
    bool isEnumType() const { return isEnumType_; }
    bool isFlagType() const { return isFlagType_; }

    const QStringList &enumNames() const { return enumNames_; }

    bool enumNameValue(const QString &name, int &value) const {
      auto p = enumNameValue_.find(name);
      if (p == enumNameValue_.end()) return false;

      value = (*p).second;

      return true;
    }

    bool enumValueName(int value, QString &name) const {
      auto p = enumValueName_.find(value);
      if (p == enumValueName_.end()) return false;

      name = (*p).second;

      return true;
    }

   private:
    using NameValueMap = std::map<QString, int>;
    using ValueNameMap = std::map<int, QString>;

    QString        name_;
    QVariant::Type type_       { QVariant::Invalid };
    QString        typeName_;
    bool           isWritable_ { false };
    bool           isEnumType_ { false };
    bool           isFlagType_ { false };
    QStringList    enumNames_;
    NameValueMap   enumNameValue_;
    ValueNameMap   enumValueName_;
  };

  void initProperties();

#ifdef CQUTIL_EVENT
  CMouseEvent *convertEvent(QMouseEvent *event);
  CKeyEvent   *convertEvent(QKeyEvent *event);

  CMouseButton   convertButton(Qt::MouseButton button);
  CKeyType       convertKey(int key, Qt::KeyboardModifiers modifiers);
  CEventModifier convertModifier(Qt::KeyboardModifiers modifiers);
#endif

  QColor rgbToColor(const CRGB &rgb);
  QColor rgbaToColor(const CRGBA &rgba);

  inline QColor toQColor(const CRGB  &rgb ) { return rgbToColor (rgb ); }
  inline QColor toQColor(const CRGBA &rgba) { return rgbaToColor(rgba); }

  uint rgbaToInt(const CRGBA &rgba);

  CRGB  colorToRGB(const QColor &color);
  CRGBA colorToRGBA(const QColor &color);

  Qt::PenCapStyle  toPenCapStyle (const CLineCapType  &lineCap);
  Qt::PenJoinStyle toPenJoinStyle(const CLineJoinType &lineJoin);

  inline CRGBA fromQColor(const QColor &color) { return colorToRGBA(color); }

  void decodeFont(const QFont &font, QString &family, CFontStyle &style, int &pixelSize);

  //---

  QString fullName(const QObject* object);

  QObject *nameToObject(const QString &name);
  QObject *nameToObject(QObject *parent, const QString &name);

  QObject *hierChildObject(QObject *object, int ind, const QStringList &names);

  QObject *childObject(QObject *parent, const QString &name);

  QString addObjectAlias(QObject *object);

  //---

  QWidget *getToplevelWidget(QWidget *widget);

  //---

  int getNumProperties(const QObject *object, bool inherited=true);

  QStringList getPropertyList(const QObject *object, bool inherited=true);

  QStringList getPropertyList(const QObject *object, bool inherited,
                              const QMetaObject* metaObject);

  QString getPropertyName(const QObject *object, int ind, bool inherited=true);

  QVariant::Type getPropertyType(const QObject *object, int ind, bool inherited=true);

  QString getPropertyTypeName(const QObject *object, int ind, bool inherited=true);

  QVariant getPropertyValue(const QObject *object, int ind, bool inherited=true);

  bool getPropertyValueIsEnum(const QObject *object, int ind, bool inherited=true);
  bool getPropertyValueIsFlag(const QObject *object, int ind, bool inherited=true);

  QString getPropertyEnumName(const QObject *object, int ind, bool inherited=true);

  QString getPropertyEnumValue(const QObject *object, int ind, bool inherited=true);

  QStringList getMetaPropertyEnumNames(const QObject *object, int ind, bool inherited=true);
  QList<int> getMetaPropertyEnumValues(const QObject *object, int ind, bool inherited=true);

  bool getMetaPropertyEnumNameValues(const QObject *object, int ind, bool inherited,
                                     QStringList &names, QList<int> &values);

  bool enumPropertyValueToString(const QObject *object, int ind, bool inherited,
                                 int value, QString &str);
  bool enumPropertyStringToValue(const QObject *object, int ind, bool inherited,
                                 const QString &str, int &value);

  bool stringToEnumValue(const QString &str, const QMetaProperty &metaProperty, int &value);

  bool stringToEnumSubValue(const QString &str, const QMetaEnum &metaEnum, int &value);

  bool getMetaPropertyEnum(const QObject *object, int ind, bool inherited,
                           QMetaProperty &metaProperty, QMetaEnum &metaEnum, bool &isFlag);

  bool getMetaProperty(const QObject *object, int ind, bool inherited,
                       QMetaProperty &metaProperty);

  bool hasProperty(const QObject *object, const QString &name);
  bool hasWritableProperty(const QObject *object, const QString &name);

  bool getProperty(const QObject *object, const QString &name, QVariant &value);

  bool getTclProperty(const QObject *object, const QString &propName, QVariant &v);

  bool setPropertyValue(QObject *object, int ind, const QVariant &value, bool inherited=true);

  bool setProperty(const QObject *object, const QString &name, const QString &value);
  bool setProperty(const QObject *object, const QString &name, const QVariant &value);

  bool getPropertyInfo(const QObject *object, int ind, PropInfo *info, bool inherited=true);

  bool getPropInfo(const QObject *object, const QString &name, PropInfo *info);

  bool getPropInfoEnumNameValue(const CQUtil::PropInfo &propInfo, const QString &name, int &value);
  bool getPropInfoEnumValueName(const CQUtil::PropInfo &propInfo, int value, QString &name);

  //---

  QString className(const QObject *object);

  QStringList hierClassNames(const QObject *object);

  const QMetaObject *baseClass(QMetaObject *metaObject, const char *name);

  //---

  int numSignals(const QObject *object, bool hierarchical=true);

  QString signalName(const QObject *object, int ind, bool hierarchical=true);

  QStringList signalNames(const QObject* object, bool inherited=true);

  //---

  int numSlots(const QObject *object, bool hierarchical=true);

  QString slotName(const QObject *object, int ind, bool hierarchical=true);

  QStringList slotNames(const QObject* object, bool inherited=true);

  //---

  QString eventTypeToName(QEvent::Type type);
  QString eventToString(QEvent *event);

  QColor getForeground(QWidget *widget);
  void   setForeground(QWidget *widget, const QColor &color);

  QColor getBackground(QWidget *widget);
  void   setBackground(QWidget *widget, const QColor &color);

  QPointF  toQPoint  (const CPoint2D &point);
  QPoint   toQPointI (const CPoint2D &point);
  CPoint2D fromQPoint(const QPointF &point);

  QPoint    toQPoint   (const CIPoint2D &point);
  CIPoint2D fromQPoint (const QPoint &point);
  CPoint2D  fromQPointF(const QPoint &point);

  QSizeF  toQSize  (const CSize2D &size);
  CSize2D fromQSize(const QSizeF &size);

  QSize    toQSize  (const CISize2D &size);
  CISize2D fromQSize(const QSize &size);

  QRectF  toQRect  (const CBBox2D &rect);
  QRect   toQRectI (const CBBox2D &rect);
  CBBox2D fromQRect(const QRectF &rect);

  QRect    toQRect  (const CIBBox2D &rect);
  CIBBox2D fromQRect(const QRect &rect);

  QMatrix   toQMatrix  (const CMatrix2D &m);
  CMatrix2D fromQMatrix(const QMatrix &m);

  QTransform toQTransform  (const CMatrix2D &m);
  CMatrix2D  fromQTransform(const QTransform &t);

  QString variantToString(const QVariant &var);
  bool variantToString(const QVariant &var, QString &str);

  bool stringToVariant(const QString &str, QVariant::Type type, const char *typeName,
                       int userType, QVariant &var, const QVariant &oldVar=QVariant());

  bool paletteFromString(QPalette &palette, const QString &paletteDef);
  QString paletteToString(const QPalette &palette);

  bool activateSlot(QObject *receiver, const char *slotName, const char *valuesStr);
  bool activateSignal(QObject* sender, const char *signalName, const char *valuesStr);

  //---

  bool userVariantToString(const QVariant &var, QString &str);
  bool userVariantFromString(QVariant &ivar, const QString &str);

  //---

  /*! template function to get table cell widget of type */
  template<typename T>
  T tableCellWidget(QTableWidget *table, int row, int col) {
    return qobject_cast<T>(table->cellWidget(row, col));
  }

  //---

#ifdef CQUTIL_GRADIENT
  QLinearGradient toQGradient(const CLinearGradient *lgradient,
                              QGradient::CoordinateMode mode=QGradient::ObjectBoundingMode);
  QRadialGradient toQGradient(const CRadialGradient *rgradient,
                              QGradient::CoordinateMode mode=QGradient::ObjectBoundingMode);
#endif

  void getScreenSize(uint *w, uint *h);

  void setSelectText(const std::string &text);

  void setDockVisible(QDockWidget *dock, bool visible);

#ifdef CQUTIL_LINE_DASH
  void penSetLineDash(QPen &pen, const CLineDash &dash);
#endif

  QString alignToString(Qt::Alignment align);
  bool stringToAlign(const QString &str, Qt::Alignment &align);

  Qt::Alignment toQAlign(CHAlignType halign);
  Qt::Alignment toQAlign(CVAlignType valign);

  CHAlignType toHAlign(Qt::Alignment align);
  CVAlignType toVAlign(Qt::Alignment align);

  //-----

  QPixmap getPixmap(const QString &name);

  QIcon getIcon(const QString &name);

  //-----

  uint nameWidgetTree(QWidget *widget);

  void nameWidget(QWidget *widget);
  void nameObject(QObject *object);

  void nameWidgetButton(QAbstractButton *button);
  void nameWidgetLabel(QLabel *label);
  void nameObjectGen(QObject *object);

  //-----

  void recolorImage(QImage &image, const QColor &fg, const QColor &bg);

  //-----

  void drawHtmlText(QWidget *w, QPainter *painter, const QString &text,
                    const QPalette &palette, const QRect &rect, bool active=false);

  QString colorToHtml(const QColor &c);

  //----

  QString policyToString(QSizePolicy::Policy policy);

  //----

  QColor blendColors(const QColor &c1, const QColor &c2, double f);
}

//---

namespace CQUtil {
  template<class T>
  T *makeWidget(const QString &objName="") {
    T *t = new T;

    if (objName != "")
      t->setObjectName(objName);

    return t;
  }

  template<class T>
  T *makeWidget(QWidget *parent, const QString &objName="") {
    T *t = new T(parent);

    if (objName != "")
      t->setObjectName(objName);

    return t;
  }

  template<class T>
  T *makeLabelWidget(const QString &name, const QString &objName="") {
    T *t = new T(name);

    if (objName != "")
      t->setObjectName(objName);

    return t;
  }

  template<class T>
  T *makeLabelWidget(QWidget *parent, const QString &name, const QString &objName="") {
    T *t = new T(name, parent);

    if (objName != "")
      t->setObjectName(objName);

    return t;
  }

  template<class T>
  T *makeLayout(QWidget *parent, int margin=2, int spacing=2) {
    T *t = new T(parent);

    t->setMargin (margin );
    t->setSpacing(spacing);

    return t;
  }

  template<class T>
  T *makeLayout(QBoxLayout *parent, int margin=2, int spacing=2) {
    T *t = new T;

    t->setMargin (margin );
    t->setSpacing(spacing);

    parent->addLayout(t);

    return t;
  }

  template<class T>
  T *makeLayout(int margin=2, int spacing=2) {
    T *t = new T;

    t->setMargin (margin );
    t->setSpacing(spacing);

    return t;
  }

  inline QButtonGroup *makeButtonGroup(QWidget *parent,
   const std::initializer_list<QAbstractButton *> &buttons) {
    auto *buttonGroup = new QButtonGroup(parent);

    int ind = 0;

    for (auto button : buttons)
      buttonGroup->addButton(button, ind++);

    return buttonGroup;
  }

  //---

  inline QAction *addAction(QMenu *menu, const QString &name,
                            QObject *receiver=nullptr, const char *slotName=nullptr) {
    auto *action = new QAction(name, menu);

    if (slotName)
      QObject::connect(action, SIGNAL(triggered()), receiver, slotName);

    menu->addAction(action);

    return action;
  }

  inline QAction *addCheckedAction(QMenu *menu, const QString &name, bool checked,
                                   QObject *receiver=nullptr, const char *slotName=nullptr) {
    auto *action = new QAction(name, menu);

    action->setCheckable(true);
    action->setChecked(checked);

    if (slotName)
      QObject::connect(action, SIGNAL(triggered(bool)), receiver, slotName);

    menu->addAction(action);

    return action;
  }

  inline QActionGroup *createActionGroup(QMenu *menu, QObject *receiver=nullptr,
                                         const char *slotName=nullptr) {
    auto *actionGroup = new QActionGroup(menu);

    if (slotName)
       QObject::connect(actionGroup, SIGNAL(triggered(QAction *)), receiver, slotName);

    return actionGroup;
  }

  inline QAction *addGroupCheckAction(QActionGroup *group, const QString &name, bool checked,
                                      QObject *receiver=nullptr, const char *slotName=nullptr) {
    auto *menu = qobject_cast<QMenu *>(group->parent());
    assert(menu);

    auto *action = new QAction(name, menu);

    action->setCheckable(true);
    action->setChecked(checked);

    if (slotName)
      QObject::connect(action, SIGNAL(triggered()), receiver, slotName);

    group->addAction(action);

    return action;
  }

  inline void addActionGroupToMenu(QActionGroup *group) {
    auto *menu = qobject_cast<QMenu *>(group->parent());
    assert(menu);

    menu->addActions(group->actions());
  }
}

//---

namespace CQUtil {
  double polygonArea(const QPolygonF &poly);

  double polygonArea2(const QPolygonF &poly);
}

//---

class QGridLayout;
class QLayoutItem;

namespace CQUtil {
  void deleteLayoutChildWidgets(QLayoutItem *item);

  void removeGridItem(QGridLayout *layout, int row, int column, bool deleteWidgets);

  void removeGridRow   (QGridLayout *layout, int row, bool deleteWidgets);
  void removeGridColumn(QGridLayout *layout, int column, bool deleteWidgets);

  void removeGridItems(QGridLayout *layout, bool deleteWidgets);
}

//---

namespace CQUtil {
  bool isFixedPitch(const QFont &font);

  QFont getMonospaceFont();
}

#endif
##concat##CQUtilMeta.h
#ifndef CQUtilMeta_H
#define CQUtilMeta_H

/*!
 * Macros to help define custom data types supported by Qt variant
 * code so can be used in Q_PROPERTY defines and get/set using tcl
 *
 * To defined an new type <TYPE>:
 *  . Add the following to the end of the type's header file:
 *     #include <CQUtilMeta.h>
 *     CQUTIL_DCL_META_TYPE(<TYPE>)
 *
 *  . Add the following to the top of the type's C++ file:
 *     CQUTIL_DEF_META_TYPE(<TYPE>, toString, fromString)
 *    where
 *     'QString toString() const' gets the string representation of <TYPE>.
 *     'bool fromString(const QString &str) const' sets the instance of <TYPE> from a string.
 *
 *  . Add code to call at startup
 *     CQUTIL_REGISTER_META(<TYPE>)
 */

#include <QMetaType>
#include <QDataStream>
#include <QDebug>

namespace CQUtilMetaData {
  inline bool *resultPtr() {
    static bool result;
    return &result;
  }

  inline bool getResult() { return *resultPtr(); }
  inline void setResult(bool b) { *resultPtr() = b; }
}

//---

#define CQUTIL_DCL_META_TYPE(TYPE) \
Q_DECLARE_METATYPE(TYPE) \
\
QDataStream &operator<<(QDataStream &out, const TYPE &t); \
\
QDataStream &operator>>(QDataStream &in, TYPE &t); \
\
QDebug operator<<(QDebug dbg, const TYPE &t);

//---

// convert meta type to/from data stream using GETTER and SETTER member functions that
// return and take QString
#define CQUTIL_DEF_META_TYPE_DATA_STREAM(TYPE, GETTER, SETTER) \
QDataStream &operator<<(QDataStream &out, const TYPE &t) { \
  QString str = t.GETTER(); \
  out << str; \
  return out; \
} \
\
QDataStream &operator>>(QDataStream &in, TYPE &t) { \
  QString str; \
  in >> str; \
  CQUtilMetaData::setResult(t.SETTER(str)); \
  return in; \
}

// convert meta type to/from data stream using GETTER and SETTER member functions that
// return and take std::string
#define CQUTIL_DEF_META_TYPE_STD_DATA_STREAM(TYPE, GETTER, SETTER) \
QDataStream &operator<<(QDataStream &out, const TYPE &t) { \
  QString str = t.GETTER().c_str(); \
  out << str; \
  return out; \
} \
\
QDataStream &operator>>(QDataStream &in, TYPE &t) { \
  QString str; \
  in >> str; \
  CQUtilMetaData::setResult(t.SETTER(str.toStdString())); \
  return in; \
} \

// convert meta type to/from debug using GETTER and SETTER member functions that
// return and take QString
#define CQUTIL_DEF_META_TYPE_DEBUG(TYPE, GETTER) \
QDebug operator<<(QDebug dbg, const TYPE &t) \
{ \
  dbg.nospace() << t.GETTER(); \
  return dbg.maybeSpace(); \
} \

// convert meta type to/from debug using GETTER and SETTER member functions that
// return and take std::string
#define CQUTIL_DEF_META_TYPE_STD_DEBUG(TYPE, GETTER) \
QDebug operator<<(QDebug dbg, const TYPE &t) \
{ \
  dbg.nospace() << t.GETTER().c_str(); \
  return dbg.maybeSpace(); \
}

// define routine to register meta type to Qt
#define CQUTIL_DEF_META_TYPE_REGISTER(TYPE, ID) \
namespace CQUtilMeta_##ID {\
int registerMetaType() { \
  static bool registered; \
  static int type = -1; \
  if (! registered) { \
    type = qRegisterMetaType<TYPE>(#TYPE); \
    qRegisterMetaTypeStreamOperators<TYPE>(#TYPE); \
    registered = true; \
  } \
  return type; \
} \
}

// define meta type using GETTER and SETTER member functions that
// return and take QString
#define CQUTIL_DEF_META_TYPE(TYPE, GETTER, SETTER) \
CQUTIL_DEF_META_TYPE_DATA_STREAM(TYPE, GETTER, SETTER) \
\
CQUTIL_DEF_META_TYPE_DEBUG(TYPE, GETTER) \
\
CQUTIL_DEF_META_TYPE_REGISTER(TYPE, TYPE)

#define CQUTIL_DEF_META_TYPE_ID(TYPE, ID, GETTER, SETTER) \
CQUTIL_DEF_META_TYPE_DATA_STREAM(TYPE, GETTER, SETTER) \
\
CQUTIL_DEF_META_TYPE_DEBUG(TYPE, GETTER) \
\
CQUTIL_DEF_META_TYPE_REGISTER(TYPE, ID)

//---

// define meta type using GETTER and SETTER member functions that
// return and take std::string
#define CQUTIL_DEF_META_TYPE_STD(TYPE, GETTER, SETTER) \
CQUTIL_DEF_META_TYPE_STD_DATA_STREAM(TYPE, GETTER, SETTER) \
\
CQUTIL_DEF_META_TYPE_STD_DEBUG(TYPE, GETTER) \
\
CQUTIL_DEF_META_TYPE_REGISTER(TYPE, TYPE)

//---

// call routine to register meta type
#define CQUTIL_REGISTER_META(TYPE) CQUtilMeta_##TYPE :: registerMetaType()

#define CQUTIL_REGISTER_META_ID(ID) CQUtilMeta_##ID :: registerMetaType()

//---

// define type check, convert from and to QVariant functions
#define CQUTIL_DEF_META_CONVERSIONS(TYPE, ID) \
static bool isVariantType(const QVariant &var) { \
  return (var.type() == QVariant::UserType && var.userType() == ID); \
} \
\
static TYPE fromVariant(const QVariant &var) { \
  return var.value<TYPE>(); \
} \
\
static QVariant toVariant(const TYPE &value) { \
  return QVariant::fromValue<TYPE>(value); \
}

#endif
##concat##CQWidgetFactory.h
#ifndef CQWidgetFactory_H
#define CQWidgetFactory_H

#include <QObject>

class QWidget;
class QLayout;

class CQWidgetFactory {
 public:
  CQWidgetFactory() { }

  virtual ~CQWidgetFactory() { }

  virtual QWidget *createWidget(QWidget *parent=nullptr,
                                const QStringList &params=QStringList()) = 0;
};

class CQLayoutFactory {
 public:
  CQLayoutFactory() { }

  virtual ~CQLayoutFactory() { }

  virtual QLayout *createLayout(QWidget *parent=nullptr,
                                const QStringList &params=QStringList()) = 0;
};

//----

template<typename T>
class CQWidgetFactoryT : public CQWidgetFactory {
 public:
  CQWidgetFactoryT() { }

  QWidget *createWidget(QWidget *parent, const QStringList &) {
    auto *w = new T(parent);

    // TODO: set object name

    return w;
  }
};

template<typename T>
class CQWidgetFactoryNoArgsT : public CQWidgetFactory {
 public:
  CQWidgetFactoryNoArgsT() { }

  QWidget *createWidget(QWidget *, const QStringList &) {
    auto *w = new T();

    // TODO: set object name

    return w;
  }
};

template<typename T>
class CQLayoutFactoryT : public CQLayoutFactory {
 public:
  CQLayoutFactoryT() { }

  QLayout *createLayout(QWidget *parent, const QStringList &) {
    auto *w = new T(parent);

    // TODO: set object name

    return w;
  }
};

//---

#define CQWidgetFactoryMgrInst CQWidgetFactoryMgr::instance()

class CQWidgetFactoryMgr : public QObject {
  Q_OBJECT

 public:
  static CQWidgetFactoryMgr *instance();

  CQWidgetFactoryMgr();
 ~CQWidgetFactoryMgr();

  //---

  bool isWidgetFactory(const QString &name) const;

  template<typename T>
  void addWidgetFactoryT(const QString &name) {
    addWidgetFactory(name, new CQWidgetFactoryT<T>());
  }

  template<typename T>
  void addWidgetFactoryNoArgsT(const QString &name) {
    addWidgetFactory(name, new CQWidgetFactoryNoArgsT<T>());
  }

  void addWidgetFactory(const QString &name, CQWidgetFactory *factory);

  void removeWidgetFactory(const QString &name);

  CQWidgetFactory *getWidgetFactory(const QString &name) const;

  QStringList widgetFactoryNames() const;

  //---

  bool isLayoutFactory(const QString &name) const;

  void addLayoutFactory(const QString &name, CQLayoutFactory *factory);

  void removeLayoutFactory(const QString &name);

  CQLayoutFactory *getLayoutFactory(const QString &name) const;

  QStringList layoutFactoryNames() const;

  //---

  QWidget *createWidget(const QString &type, QWidget *parent=nullptr,
                        const QStringList &options=QStringList());

  QLayout *createLayout(const QString &type, QWidget *parent=nullptr,
                        const QStringList &options=QStringList());

 private:
  void init();

 private:
  using WidgetFactories = std::map<QString, CQWidgetFactory *>;
  using LayoutFactories = std::map<QString, CQLayoutFactory *>;

  WidgetFactories widgetFactories_;
  LayoutFactories layoutFactories_;
};

#endif
##concat##CQWidgetMenu.h
#ifndef CQWidgetMenu_H
#define CQWidgetMenu_H

#include <QWidget>
#include <QWidgetAction>
#include <QMenu>

/*!
  \ingroup CQWidgetMenu

  \brief Creates a menu containing a widget

  The CQWidgetMenu class provides a popup menu which can hold a fixed sized widget.

  To use create a CQWidgetMenu widget and a contents widget and use the setWidget()
  method to store the widget in the menu. The menu uses the contents widget's
  sizeHint to determine the menu size.
*/

class CQWidgetMenuAction;
class CQWidgetMenuArea;

/*!
  \ingroup CQWidgetMenu

  \brief Widget menu

  Widget Menu class.

  To use:
    . create a CQWidgetMenu widget
    . create a custom contents widget
    . Call setWidget to passing the contents widget
*/
class CQWidgetMenu : public QMenu {
  Q_OBJECT

 public:
  //! create menu
  CQWidgetMenu(QWidget *parent=nullptr);

  //! get menu action
  CQWidgetMenuAction *getAction() const;

  //! set contents widget
  void setWidget(QWidget *widget);

  //! create menu action
  virtual CQWidgetMenuAction *createAction();

  //! create area widget
  virtual CQWidgetMenuArea *createArea() const;

  //! reset menu size
  void resetSize();

  void updateAreaSize();

  void paintEvent(QPaintEvent *) override;

  QSize sizeHint() const override;

 signals:
  //! signal emitted before menu is shown
  void menuShown();

  //! signal emitted after menu is hidden
  void menuHidden();

 protected:
  CQWidgetMenuAction *action_ { nullptr }; // menu action widget
};

/*!
  \ingroup CQWidgetMenu

  \brief Widget menu area

  The widget menu area contains the area widget (to hold content widget)

  Internal class - DO NOT USE
*/
class CQWidgetMenuArea : public QWidget {
  Q_OBJECT

 public:
  //! create menu area
  CQWidgetMenuArea(QWidget *parent=nullptr);

  //! delete menu area
  virtual ~CQWidgetMenuArea() { }

  //! set contents widget
  virtual void setWidget(QWidget *w);

  //! get area widget
  QWidget *getWidget() const { return areaWidget_; }

  //! get menu action
  CQWidgetMenuAction *getAction() const { return action_; }

  //! set menu action
  void setAction(CQWidgetMenuAction *action);

  //! set menu size
  virtual void setSize(int w, int h);

  //! reset menu size
  virtual void resetSize();

  //! return size hint
  QSize sizeHint() const override;

  //! update widget placement in menu
  virtual void updateLayout();

  //! handle menu shown
  virtual void menuShow();

  //! handle menu hidden
  virtual void menuHide();

 private:
  //! handle resize event
  void resizeEvent(QResizeEvent *) override;

 private slots:
  //! handle menu shown signal
  void menuShowSlot();

  //! handle menu hidden signal
  void menuHideSlot();

 signals:
  //! notify menu shown
  void menuShown();

  //! notify menu hidden
  void menuHidden();

 protected:
  CQWidgetMenuAction *action_     { nullptr }; // menu action widget
  int                 w_ { 0 }, h_ { 0 };      // current width/height
  QWidget            *area_       { nullptr }; // container widget for content widget
  QWidget            *areaWidget_ { nullptr }; // content widget
};

/*!
  \ingroup CQWidgetMenu

  \brief Menu action widget

  Widget action to interface between widget contents and menu API

  Internal class - DO NOT USE
*/
class CQWidgetMenuAction : public QWidgetAction {
 public:
  CQWidgetMenuAction(CQWidgetMenu *menu);

 ~CQWidgetMenuAction();

  //! get parent menu
  CQWidgetMenu *getMenu() const { return menu_; }

  //! get menu contents area
  CQWidgetMenuArea *getArea() const;

  //! get menu content widget (required implementation for QWidgetAction)
  QWidget *getWidget() const;

 private:
  //! create menu widget (required implementation for QWidgetAction)
  QWidget *createWidget(QWidget *parent);

 protected:
  CQWidgetMenu     *menu_ { nullptr }; //! parent menu
  CQWidgetMenuArea *area_ { nullptr }; //! menu contents area
};

#endif
##concat##CQWidgetPtr.h
#ifndef CQWidgetPtr_H
#define CQWidgetPtr_H

#include <QObject>

class CQWidgetPtr : public QObject {
  Q_OBJECT

 public:
  CQWidgetPtr(QWidget *w=nullptr) :
   w_(w) {
    watch();
  }

  bool isValid() const {
    return (w_ != nullptr);
  }

  void set(QWidget *w) {
    w_ = w;

    watch();
  }

  QWidget *get() const {
    return w_;
  }

  template<typename T>
  T *get() const {
    return dynamic_cast<T *>(w_);
  }

 private:
  void watch() {
    if (w_)
      connect(w_, SIGNAL(destroyed(QObject *)), this, SLOT(resetSlot()));
  }

 private slots:
  void resetSlot() {
    w_ = nullptr;
  }

 private:
  QWidget *w_;
};

#endif
##concat##CQWidgetUtil.h
#ifndef CQWidgetUtil_H
#define CQWidgetUtil_H

#include <QWheelEvent>
#include <QApplication>
#include <QScreen>

namespace CQWidgetUtil {
  inline void resetWidgetMinMaxWidth(QWidget *w) {
    w->setMinimumWidth(0); w->setMaximumWidth(QWIDGETSIZE_MAX);
  }

  inline void resetWidgetMinMaxHeight(QWidget *w) {
    w->setMinimumHeight(0); w->setMaximumHeight(QWIDGETSIZE_MAX);
  }

  inline void resetWidgetMinMaxSize(QWidget *w) {
    resetWidgetMinMaxWidth (w);
    resetWidgetMinMaxHeight(w);
  }

  inline void setWidgetFixedWidth(QWidget *w, int width) {
    w->setFixedWidth(width);
  }

  inline void setWidgetFixedHeight(QWidget *w, int height) {
    w->setFixedHeight(height);
  }

  inline void setWidgetMinMaxWidth(QWidget *w, int min_w, int max_w) {
    w->setMinimumWidth(min_w); w->setMaximumWidth(max_w);
  }

  inline void setWidgetMinMaxHeight(QWidget *w, int min_h, int max_h) {
    w->setMinimumHeight(min_h); w->setMaximumHeight(max_h);
  }

  inline QSize SmartMinSize(const QSize &sizeHint, const QSize &minSizeHint,
                            const QSize &minSize, const QSize &maxSize,
                            const QSizePolicy &sizePolicy) {
    QSize s(0, 0);

    if (sizePolicy.horizontalPolicy() != QSizePolicy::Ignored) {
      if (uint(sizePolicy.horizontalPolicy()) & QSizePolicy::ShrinkFlag)
        s.setWidth(minSizeHint.width());
      else
        s.setWidth(qMax(sizeHint.width(), minSizeHint.width()));
    }

    if (sizePolicy.verticalPolicy() != QSizePolicy::Ignored) {
      if (uint(sizePolicy.verticalPolicy()) & QSizePolicy::ShrinkFlag)
        s.setHeight(minSizeHint.height());
      else
        s.setHeight(qMax(sizeHint.height(), minSizeHint.height()));
    }

    s = s.boundedTo(maxSize);

    if (minSize.width() > 0)
      s.setWidth(minSize.width());

    if (minSize.height() > 0)
      s.setHeight(minSize.height());

    return s.expandedTo(QSize(0, 0));
  }

  inline QSize SmartMinSize(const QWidget *w) {
    return SmartMinSize(w->sizeHint(), w->minimumSizeHint(),
                        w->minimumSize(), w->maximumSize(),
                        w->sizePolicy());
  }

  inline void getContentsMargins(const QWidget *w, int *l, int *t, int *r, int *b) {
    auto m = w->contentsMargins();

    if (l) *l = m.left  ();
    if (t) *t = m.top   ();
    if (r) *r = m.right ();
    if (b) *b = m.bottom();
  }

  inline int wheelDelta(QWheelEvent *e) {
    return e->angleDelta().y();
  }

  inline QRect desktopAvailableGeometry(QWidget * /*w*/ =nullptr) {
#if 0
    if (w)
      return qApp->desktop()->availableGeometry(w);
    else
      return qApp->desktop()->availableGeometry();
#else
    auto *screen = QApplication::screens().at(0);

    return screen->availableGeometry();
#endif
  }

  inline QRect desktopAvailableGeometry(const QWidget * /*w*/, const QPoint &pos) {
#if 0
    auto *desktop = QApplication::desktop();

    int snum;

    if (desktop->isVirtualDesktop())
      snum = desktop->screenNumber(pos);
    else
      snum = desktop->screenNumber(this);

    return desktop->availableGeometry(snum);
#else
    auto *screen = qApp->screenAt(pos);

    return screen->availableGeometry();
#endif
  }
}

#endif
##concat##CQWindow.h
#ifndef CQWINDOW_H
#define CQWINDOW_H

#include <QWidget>

#include <CWindow.h>

class CQWindowFactory : public CWindowFactory {
 public:
  CWindow *createWindow(int x, int y, uint width, uint height);

  CWindow *createWindow(CWindow *parent, int x, int y, uint width, uint height);
};

//------

class CQWindow : public QWidget, public CWindow {
  Q_OBJECT

 public:
  static void setFactory();
  static void resetFactory();

 public:
  CQWindow(CQWindow *parent=nullptr);

  CQWindow(QWidget *parent);

  virtual ~CQWindow();

  virtual bool isPressed() const { return pressed_; }
  virtual void setPressed(bool b);

  // get current position and size
  void getPosition(int *x, int *y) const override;
  void getSize(uint *w, uint *h) const override;

  void getScreenSize(uint *w, uint *h) const override;

  // destrow window
  void destroy() override;

  // move window
  void move(int x, int y) override;

  // resize window
  void resize(uint width, uint height) override;

  // map/unmap window
  void map  () override;
  void unmap() override;

  // get if window is mapped
  bool isMapped() override;

  // iconize/deiconize window
  void iconize  () override;
  void deiconize() override;

  // maximize/demaximize window
  void maximize  () override;
  void demaximize() override;

  // lower/raise window
  void lower() override;
  void raise() override;

  // set window/icon title
  void setWindowTitle(const std::string &title) override;
  void setIconTitle(const std::string &) override;

  // get window/icon title
  void getWindowTitle(std::string &title) const override;
  void getIconTitle(std::string &title) const override;

  // signal expose event
  void expose() override;

  // set event adapter
  void setEventAdapter(CEventAdapter *eventAdpater) override;

  // property
  bool setProperty(const std::string &name, const std::string &value) override;

  // selection
  bool setSelectText(const std::string &text) override;

  // draw window contents
  void redraw() override;

  void beep() override;

  //------

  // hints

  virtual void setMinSize(int width, int height);
  virtual void setBaseSize(int width, int height);
  virtual void setResizeInc(int width, int height);

  //------

  void mousePressEvent(QMouseEvent *) override;
  void mouseReleaseEvent(QMouseEvent *) override;
  void mouseDoubleClickEvent(QMouseEvent *) override;
  void mouseMoveEvent(QMouseEvent *) override;

  void keyPressEvent(QKeyEvent *) override;
  bool keyPressEvent(const CKeyEvent &) override;
  void keyReleaseEvent(QKeyEvent *) override;
  bool keyReleaseEvent(const CKeyEvent &) override;

  void paintEvent(QPaintEvent *) override;

  void resizeEvent(QResizeEvent *) override;
  bool resizeEvent() override;

  void hideEvent(QHideEvent *) override;
  bool hideEvent() override;
  void showEvent(QShowEvent *) override;
  bool showEvent() override;

  void enterEvent(QEvent *) override;
  bool enterEvent() override;
  void leaveEvent(QEvent *) override;
  bool leaveEvent() override;

 private:
  bool pressed_ { false };
};

#endif
##concat##CQWinWidget.h
#ifndef CQWinWidget_H
#define CQWinWidget_H

#include <QWidget>
#include <QPoint>
#include <QTextEdit>
#include <QLabel>
#include <QTableWidget>
#include <QTreeWidget>

class QMenu;

class CQWinWidget : public QWidget {
  Q_OBJECT

  Q_PROPERTY(DecorationType decorationType READ decorationType WRITE setDecorationType)
  Q_PROPERTY(HeaderSide     headerSide     READ headerSide     WRITE setHeaderSide    )
  Q_PROPERTY(EditMode       editMode       READ editMode       WRITE setEditMode      )

  Q_PROPERTY(int    borderWidth   READ decorationBorder WRITE setDecorationBorder)
  Q_PROPERTY(QColor borderColor   READ decorationColor  WRITE setDecorationColor )
  Q_PROPERTY(QColor barColor      READ barColor         WRITE setBarColor        )
  Q_PROPERTY(bool   movable       READ isMovable        WRITE setMovable         )
  Q_PROPERTY(bool   resizable     READ isResizable      WRITE setResizable       )
  Q_PROPERTY(bool   closable      READ isClosable       WRITE setClosable        )
  Q_PROPERTY(bool   transparent   READ isTransparent    WRITE setTransparent     )
  Q_PROPERTY(bool   headerVisible READ isHeaderVisible  WRITE setHeaderVisible   )

  Q_ENUMS(DecorationType)
  Q_ENUMS(HeaderSide)
  Q_ENUMS(EditMode)

 public:
  enum GeometryOps : unsigned int {
    MoveOp     = (1<<0),
    ResizeOp   = (1<<1),
    RaiseOp    = (1<<2),
    LowerOp    = (1<<3),
    CloseOp    = (1<<4),
    ExpandOp   = (1<<5),
    CollapseOp = (1<<6)
  };

  enum DecorationType : unsigned int {
    NoDecoration           = 0,
    BorderDecoration       = (1<<0),
    HeaderDecoration       = (1<<1),
    HeaderBorderDecoration = (BorderDecoration | HeaderDecoration)
  };

  enum EditMode {
    EDIT_MODE_DRAG,
    EDIT_MODE_CLICK
  };

  enum HeaderSide {
    SideLeft,
    SideRight,
    SideTop,
    SideBottom
  };

  enum Constraint {
    NO_CONSTRAINT,
    VISIBLE_CONSTRAINT,
    UNCLIPPED_CONSTRAINT
  };

 private:
  struct Decoration {
    DecorationType type         { HeaderBorderDecoration };
    HeaderSide     headerSide   { SideTop };
    int            headerHeight { 0 };
    QRect          headerRect;
    int            border       { 0 };
    QColor         borderColor  { Qt::white };
    QColor         barColor     { 100, 100, 240 };

    Decoration() = default;

    Decoration(DecorationType type, HeaderSide headerSide, int headerHeight,
               int border, const QColor &borderColor, const QColor &barColor) :
     type(type), headerSide(headerSide), headerHeight(headerHeight),
     border(border), borderColor(borderColor), barColor(barColor) {
    }
  };

  //---

  struct HeaderButton {
    QString iconName;
    QIcon   icon;
    QRect   rect;
    bool    displayed { false };
    bool    active    { false };
    bool    pressed   { false };

    HeaderButton(const QString &iconName);

    void updateActive(const QPoint &p, bool pressed1);

    void draw(QPainter *painter, CQWinWidget *preview);
  };

  //---

  struct CloseButton : public HeaderButton {
    CloseButton(const QString &iconName) : HeaderButton(iconName) { }
  };

  struct ExpandButton : public HeaderButton {
    ExpandButton(const QString &iconName) : HeaderButton(iconName) { }
  };

  struct CollapseButton : public HeaderButton {
    CollapseButton(const QString &iconName) : HeaderButton(iconName) { }
  };

  //---

  struct State {
    QPoint initPos;
    QSize  initSize;
    QPoint pressPos;
    bool   moving   { false };
    bool   resizing { false };
    bool   resizeL  { false };
    bool   resizeT  { false };
    bool   resizeR  { false };
    bool   resizeB  { false };

    State() { }
  };

  //---

 public:
  CQWinWidget(QWidget *parent=nullptr, const char *name=nullptr);

  virtual ~CQWinWidget() { }

  void setChild(QWidget *child);

  void fitChild();

  //---

  DecorationType decorationType() const { return decoration_.type; }
  void setDecorationType(DecorationType type) { decoration_.type = type; updateSize(); }

  HeaderSide headerSide() const { return decoration_.headerSide; }
  void setHeaderSide(HeaderSide side) { decoration_.headerSide = side; updateSize(); }

  void setDecorationHeaderHeight(int height) { decoration_.headerHeight = height; updateSize(); }

  int decorationBorder() const { return decoration_.border; }
  void setDecorationBorder(int border) { decoration_.border = border; updateSize(); }

  const QColor &decorationColor() const { return decoration_.borderColor; }
  void setDecorationColor(const QColor &c) { decoration_.borderColor = c; update(); }

  const QColor &barColor() const { return decoration_.barColor; }
  void setBarColor(const QColor &c) { decoration_.barColor = c; update(); }

  unsigned int ops() const { return ops_; }
  void setOps(unsigned int ops) { ops_ = ops; updateSize(); }

  bool isMovable() const { return ops_ & MoveOp; }
  void setMovable(bool movable) {
    ops_ = (movable ? ops_ | MoveOp : ops_ & ~MoveOp); updateSize(); }

  bool isResizable() const { return ops_ & ResizeOp; }
  void setResizable(bool resizable) {
    ops_ = (resizable ? ops_ | ResizeOp : ops_ & ~ResizeOp); updateSize(); }

  bool isClosable() const { return ops_ & CloseOp; }
  void setClosable(bool closable) {
    ops_ = (closable ? ops_ | CloseOp : ops_ & ~CloseOp); updateSize(); }

  bool isTransparent() const { return ! autoFillBackground(); }
  void setTransparent(bool flag=true) { setAutoFillBackground(! flag); update(); }

  EditMode editMode() const { return editMode_; }
  void setEditMode(EditMode editMode) { editMode_ = editMode; }

  bool isHeaderVisible() const { return (decoration_.type & HeaderDecoration); }
  void setHeaderVisible(bool visible) {
    decoration_.type = static_cast<DecorationType>
      (visible ? decoration_.type |  HeaderDecoration : decoration_.type & ~HeaderDecoration);
    updateSize(); }

  void setConstraint(Constraint constraint) { constraint_ = constraint; }

  void setChildSize(const QSize &size);

  //---

  // get x/y position inside frame
  int getX() const;
  int getY() const;

  int getWidth () const;
  int getHeight() const;

  int getHeaderHeight() const;

  // get x/y position in parent coords
  int getXPos() const;
  int getYPos() const;

  // set postion of widget in parent coords
  void setPos(int x, int y);

  void setSize(int w, int h);

  virtual bool checkMove(QPoint &p) const;

  virtual bool checkGeometry(const QRect &r) const;

  int getBorder() const;

  void drawHeaderButtonH(QPainter *painter, HeaderButton &button, int &x1, int y1, int b1);
  void drawHeaderButtonV(QPainter *painter, HeaderButton &button, int x1, int &y1, int b1);

  //---

  void showContextMenu(const QPoint &p);

  void updateSize();

 private slots:
  void setHeaderSlot(bool);

  void closeSlot();
  void expandSlot();
  void collapseSlot();

 signals:
  void geometryChanging();
  void geometryChanged();

  void closing();
  void closed();
  void expand();
  void collapse();

 private:
  void paintEvent(QPaintEvent *event) override;

  void moveEvent  (QMoveEvent *event) override;
  void resizeEvent(QResizeEvent *event) override;

  void mousePressEvent  (QMouseEvent *event) override;
  void mouseMoveEvent   (QMouseEvent *event) override;
  void mouseReleaseEvent(QMouseEvent *event) override;

  void contextMenuEvent(QContextMenuEvent *event) override;

  void enterEvent(QEvent *) override;
  void leaveEvent(QEvent *) override;

  void showEvent(QShowEvent *) override;
  void hideEvent(QHideEvent *) override;

  void setCursor(const uchar *bits, const uchar *mask, int xo, int yo);

 private:
  QWidget*       child_          { nullptr };
  bool           active_         { false };
  bool           pressed_        { false };
  Decoration     decoration_;
  CloseButton    closeButton_    { "CLOSE" };
  ExpandButton   expandButton_   { "MAXIMIZE" };
  CollapseButton collapseButton_ { "MINIMIZE" };
  State          state_;
  unsigned int   ops_            { MoveOp | ResizeOp | RaiseOp | LowerOp | CloseOp };
  EditMode       editMode_       { EDIT_MODE_DRAG };
  Constraint     constraint_     { NO_CONSTRAINT };
};

//------

class CQWinWidgetBase {
 public:
  CQWinWidgetBase(QWidget *parent);

  virtual ~CQWinWidgetBase();

  CQWinWidget *widget() const { return widget_; }

  int getX() const { return widget_->x() + widget_->getX(); }
  int getY() const { return widget_->y() + widget_->getY(); }

  int getWidth () const { return widget_->getWidth (); }
  int getHeight() const { return widget_->getHeight(); }

  void setPos (int x, int y) { widget_->setPos (x, y); }
  void setSize(int w, int h) { widget_->setSize(w, h); }

  virtual void show() = 0;
  virtual void hide() = 0;

  virtual void setText(const QString &) { }

  virtual QString getText() const { return ""; }

  virtual void setImageName(const QString &) { }

  virtual QString getImageName() const { return ""; }

  void setEditMode(CQWinWidget::EditMode editMode);

 protected:
  CQWinWidget *widget_ { 0 };
};

//------

class CQWinTextEdit : public QTextEdit, public CQWinWidgetBase {
  Q_OBJECT

 public:
  CQWinTextEdit(QWidget *parent, const char *name=0);

  virtual ~CQWinTextEdit() { }

  void show() { QTextEdit::show(); widget_->show(); }
  void hide() { QTextEdit::hide(); widget_->hide(); }

  void setText(const QString &text) { QTextEdit::setText(text); }

  QString getText() const { return QTextEdit::toPlainText(); }

 signals:
  void valueChanged();
  void geometryChanging();
  void geometryChanged();
};

//------

class CQWinImage : public QLabel, public CQWinWidgetBase {
  Q_OBJECT

 public:
  CQWinImage(QWidget *parent, const char *name=0);

  virtual ~CQWinImage() { }

  void show() override { QLabel::show(); widget_->show(); }
  void hide() override { QLabel::hide(); widget_->hide(); }

  QString getImageName() const override { return fileName_; }
  void setImageName(const QString &fileName) override;

  const QImage &getImage() const { return image_; }
  void setImage(const QImage &image);

 private:
  void contextMenuEvent(QContextMenuEvent *event) override;

 signals:
  void valueChanged();
  void geometryChanging();
  void geometryChanged();

 public slots:
  void loadImage();

 private:
  QString fileName_;
  QImage  image_;
  QMenu*  menu_ { nullptr };
};

//------

class CQWinTable : public QTableWidget, public CQWinWidgetBase {
  Q_OBJECT

 public:
  CQWinTable(QWidget *parent, const char *name=0);

  virtual ~CQWinTable() { }

  void show() { QTableWidget::show(); widget_->show(); }
  void hide() { QTableWidget::hide(); widget_->hide(); }

 signals:
  void valueChanged();
  void geometryChanging();
  void geometryChanged();
};

//------

class CQWinTree : public QTreeWidget, public CQWinWidgetBase {
  Q_OBJECT

 public:
  CQWinTree(QWidget *parent, const char *name=0);

  virtual ~CQWinTree() { }

  void show() { QTreeWidget::show(); widget_->show(); }
  void hide() { QTreeWidget::hide(); widget_->hide(); }

 signals:
  void valueChanged();
  void geometryChanging();
  void geometryChanged();
};

#endif
##concat##CQWorkspace.h
#ifndef CQWORKSPACE_H
#define CQWORKSPACE_H

#include <QObject>
#include <QMdiArea>
#include <QMdiSubWindow>
#include <QSignalMapper>

#include <CQMenu.h>

class CQWorkspaceUpdateWindowsMenuIFace {
 public:
  virtual ~CQWorkspaceUpdateWindowsMenuIFace() { }

  virtual void exec() = 0;
};

class CQWorkspaceBase {
 public:
  CQWorkspaceBase() { }

  virtual ~CQWorkspaceBase() { }

  virtual void setActiveWidget(QWidget *w) = 0;
};

class CQWorkspaceArea : public QMdiArea {
  Q_OBJECT

 public:
  CQWorkspaceArea(CQWorkspaceBase *base) :
   QMdiArea(0), base_(base) {
    setObjectName("area");
  }

 public slots:
  void setActiveWidget(QWidget *w) {
    base_->setActiveWidget(w);

    emit widgetActivated(w);
  }

 signals:
  void widgetActivated(QWidget *w);

 private:
  CQWorkspaceBase *base_;
};

template<typename W>
class CQWorkspace;

template<typename W>
class CQWorkspaceUpdateWindowsMenu : public CQWorkspaceUpdateWindowsMenuIFace {
 private:
  CQWorkspace<W> *workspace_;

 public:
  CQWorkspaceUpdateWindowsMenu(CQWorkspace<W> *workspace) :
   workspace_(workspace) {
  }

  void exec();
};

class CQWorkspaceUpdateWindowsMenuObject : public QObject {
  Q_OBJECT

 private:
  CQWorkspaceUpdateWindowsMenuIFace *iface_;

 public:
  CQWorkspaceUpdateWindowsMenuObject(CQMenu *menu, CQWorkspaceUpdateWindowsMenuIFace *iface);

 private slots:
  void updateWindowsMenu();
};

template<typename W>
class CQWorkspace : public CQWorkspaceBase {
 public:
  typedef QList<W *> WindowList;

 public:
  CQWorkspace(QMainWindow *mainWindow, const QString &name) :
   mainWindow_(mainWindow) {
    workspace_ = new CQWorkspaceArea(this);

    workspace_->setObjectName(name);

    mainWindow_->setCentralWidget(workspace_);

    windowMapper_ = new QSignalMapper(mainWindow_);

    QObject::connect(windowMapper_, SIGNAL(mapped(QWidget *)),
                     workspace_, SLOT(setActiveWidget(QWidget *)));
  }

  virtual ~CQWorkspace() { }

  QMainWindow *getMainWindow() const { return mainWindow_; }

  CQWorkspaceArea *getWorkspace() const { return workspace_; }

  QSignalMapper *getMapper() const { return windowMapper_; }

  W *addWindow(const QString &name) {
    W *window = new W(mainWindow_);

    window->setObjectName(name);

    window->setWindowTitle(name);

    window->setAttribute(Qt::WA_DeleteOnClose);

    /*QMdiSubWindow *subWindow =*/ workspace_->addSubWindow(window);

    window->show();

    return window;
  }

  W *getWindow(uint i) const {
    const WindowList &windows = windowList();

    return windows.at(i);
  }

  int getNumWindows() const {
    const WindowList &windows = windowList();

    return windows.size();
  }

  W *activeWindow() const {
    QMdiSubWindow *subWindow = workspace_->activeSubWindow();

    return dynamic_cast<W *>(subWindow ? subWindow->widget() : 0);
  }

  const WindowList &windowList() const {
    CQWorkspace *th = const_cast<CQWorkspace *>(this);

    QList<QMdiSubWindow *> widgets = workspace_->subWindowList();

    QList<QMdiSubWindow *>::iterator p1 = widgets.begin();
    QList<QMdiSubWindow *>::iterator p2 = widgets.end  ();

    th->windows_.clear();

    for ( ; p1 != p2; ++p1) {
      W *w = dynamic_cast<W *>((*p1)->widget());

      th->windows_.push_back(w);
    }

    return windows_;
  }

  void setActiveWidget(QWidget *w) {
    QList<QMdiSubWindow *> widgets = workspace_->subWindowList();

    QList<QMdiSubWindow *>::iterator p1 = widgets.begin();
    QList<QMdiSubWindow *>::iterator p2 = widgets.end  ();

    for ( ; p1 != p2; ++p1) {
      if ((*p1)->widget() == w)
        workspace_->setActiveSubWindow(*p1);
    }
  }

  void updateWindowsMenu() {
    QMenu *menu = windowsMenu_->getMenu();

    menu->clear();

    menu->addAction(closeItem_->getAction());
    menu->addAction(closeAllItem_->getAction());
    menu->addSeparator();

    menu->addAction(tileItem_->getAction());
    menu->addAction(cascadeItem_->getAction());
    //menu->addAction(arrangeItem_->getAction());

    menu->addSeparator();

    menu->addAction(nextItem_->getAction());
    menu->addAction(prevItem_->getAction());

    WindowList windows = windowList();

    if (! windows.isEmpty()) {
      menu->addSeparator();

      W *current = activeWindow();

      for (int i = 0; i < windows.size(); ++i) {
        W *window = windows.at(i);

        QAction *action = menu->addAction(window->objectName());

        action->setCheckable(true);

        action->setChecked(window == current);

        QObject::connect(action, SIGNAL(triggered()), windowMapper_, SLOT(map()));

        windowMapper_->setMapping(action, window);
      }
    }
  }

  CQMenu *addWindowsMenu() {
    windowsMenu_ = new CQMenu(mainWindow_, "&Windows");

    closeItem_ = new CQMenuItem(windowsMenu_, "Cl&ose");

    closeItem_->setShortcut("Ctrl+F4");
    closeItem_->setStatusTip("Close the active window");

    QObject::connect(closeItem_->getAction(), SIGNAL(triggered()),
                     workspace_, SLOT(closeActiveSubWindow()));

    closeAllItem_ = new CQMenuItem(windowsMenu_, "Close &All");

    closeAllItem_->setStatusTip("Close all the windows");

    QObject::connect(closeAllItem_->getAction(), SIGNAL(triggered()),
                     workspace_, SLOT(closeAllSubWindows()));

    tileItem_ = new CQMenuItem(windowsMenu_, "&Tile");

    tileItem_->setStatusTip("Tile the windows");

    QObject::connect(tileItem_->getAction(), SIGNAL(triggered()),
                     workspace_, SLOT(tileSubWindows()));

    cascadeItem_ = new CQMenuItem(windowsMenu_, "&Cascade");

    cascadeItem_->setStatusTip("Cascade the windows");

    QObject::connect(cascadeItem_->getAction(), SIGNAL(triggered()),
                     workspace_, SLOT(cascadeSubWindows()));

#if 0
    arrangeItem_ = new CQMenuItem(windowsMenu_, "Arrange &icons");

    arrangeItem_->setStatusTip("Arrange the icons");

    QObject::connect(arrangeItem_->getAction(), SIGNAL(triggered()),
                     workspace_, SLOT(arrangeIcons()));
#endif

    nextItem_ = new CQMenuItem(windowsMenu_, "Ne&xt");

    nextItem_->setStatusTip("Move the focus to the next window");

    QObject::connect(nextItem_->getAction(), SIGNAL(triggered()),
                     workspace_, SLOT(activateNextSubWindow()));

    prevItem_ = new CQMenuItem(windowsMenu_, "Pre&vious");

    prevItem_->setStatusTip("Move the focus to the prev window");

    QObject::connect(prevItem_->getAction(), SIGNAL(triggered()),
                     workspace_, SLOT(activatePreviousSubWindow()));

    //------

    CQWorkspaceUpdateWindowsMenu<W> *update =
      new CQWorkspaceUpdateWindowsMenu<W>(this);

    new CQWorkspaceUpdateWindowsMenuObject(windowsMenu_, update);

    return windowsMenu_;
  }

 private:
  QMainWindow     *mainWindow_;
  CQWorkspaceArea *workspace_;
  WindowList       windows_;
  QSignalMapper   *windowMapper_;
  CQMenu          *windowsMenu_;
  CQMenuItem      *closeItem_;
  CQMenuItem      *closeAllItem_;
  CQMenuItem      *tileItem_;
  CQMenuItem      *cascadeItem_;
//CQMenuItem      *arrangeItem_;
  CQMenuItem      *nextItem_;
  CQMenuItem      *prevItem_;
  CQMenuItem      *separatorItem_;
};

template<typename W>
void
CQWorkspaceUpdateWindowsMenu<W>::
exec() {
  workspace_->updateWindowsMenu();
}

#endif
